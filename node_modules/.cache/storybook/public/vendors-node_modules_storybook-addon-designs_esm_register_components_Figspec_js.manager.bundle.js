"use strict";
(self["webpackChunkluma_fe_workspace"] = self["webpackChunkluma_fe_workspace"] || []).push([["vendors-node_modules_storybook-addon-designs_esm_register_components_Figspec_js"],{

/***/ "./node_modules/storybook-addon-designs/esm/register/components/Figspec.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/storybook-addon-designs/esm/register/components/Figspec.js + 31 modules ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Figspec": () => (/* binding */ Figspec),
  "default": () => (/* binding */ components_Figspec)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
var react_namespaceObject = /*#__PURE__*/__webpack_require__.t(react, 2);
;// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/development/css-tag.js
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Whether the current browser supports `adoptedStyleSheets`.
 */
const supportsAdoptingStyleSheets = window.ShadowRoot &&
    (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) &&
    'adoptedStyleSheets' in Document.prototype &&
    'replace' in CSSStyleSheet.prototype;
const constructionToken = Symbol();
const styleSheetCache = new Map();
/**
 * A container for a string of CSS text, that may be used to create a CSSStyleSheet.
 *
 * CSSResult is the return value of `css`-tagged template literals and
 * `unsafeCSS()`. In order to ensure that CSSResults are only created via the
 * `css` tag and `unsafeCSS()`, CSSResult cannot be constructed directly.
 */
class CSSResult {
    constructor(cssText, safeToken) {
        // This property needs to remain unminified.
        this['_$cssResult$'] = true;
        if (safeToken !== constructionToken) {
            throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
        }
        this.cssText = cssText;
    }
    // Note, this is a getter so that it's lazy. In practice, this means
    // stylesheets are not created until the first element instance is made.
    get styleSheet() {
        // Note, if `supportsAdoptingStyleSheets` is true then we assume
        // CSSStyleSheet is constructable.
        let styleSheet = styleSheetCache.get(this.cssText);
        if (supportsAdoptingStyleSheets && styleSheet === undefined) {
            styleSheetCache.set(this.cssText, (styleSheet = new CSSStyleSheet()));
            styleSheet.replaceSync(this.cssText);
        }
        return styleSheet;
    }
    toString() {
        return this.cssText;
    }
}
const textFromCSSResult = (value) => {
    // This property needs to remain unminified.
    if (value['_$cssResult$'] === true) {
        return value.cssText;
    }
    else if (typeof value === 'number') {
        return value;
    }
    else {
        throw new Error(`Value passed to 'css' function must be a 'css' function result: ` +
            `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` +
            `to ensure page security.`);
    }
};
/**
 * Wrap a value for interpolation in a {@linkcode css} tagged template literal.
 *
 * This is unsafe because untrusted CSS text can be used to phone home
 * or exfiltrate data to an attacker controlled site. Take care to only use
 * this with trusted input.
 */
const unsafeCSS = (value) => new CSSResult(typeof value === 'string' ? value : String(value), constructionToken);
/**
 * A template literal tag which can be used with LitElement's
 * {@linkcode LitElement.styles} property to set element styles.
 *
 * For security reasons, only literal string values and number may be used in
 * embedded expressions. To incorporate non-literal values {@linkcode unsafeCSS}
 * may be used inside an expression.
 */
const css = (strings, ...values) => {
    const cssText = strings.length === 1
        ? strings[0]
        : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
    return new CSSResult(cssText, constructionToken);
};
/**
 * Applies the given styles to a `shadowRoot`. When Shadow DOM is
 * available but `adoptedStyleSheets` is not, styles are appended to the
 * `shadowRoot` to [mimic spec behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
 * Note, when shimming is used, any styles that are subsequently placed into
 * the shadowRoot should be placed *before* any shimmed adopted styles. This
 * will match spec behavior that gives adopted sheets precedence over styles in
 * shadowRoot.
 */
const adoptStyles = (renderRoot, styles) => {
    if (supportsAdoptingStyleSheets) {
        renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
    }
    else {
        styles.forEach((s) => {
            const style = document.createElement('style');
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const nonce = window['litNonce'];
            if (nonce !== undefined) {
                style.setAttribute('nonce', nonce);
            }
            style.textContent = s.cssText;
            renderRoot.appendChild(style);
        });
    }
};
const cssResultFromStyleSheet = (sheet) => {
    let cssText = '';
    for (const rule of sheet.cssRules) {
        cssText += rule.cssText;
    }
    return unsafeCSS(cssText);
};
const getCompatibleStyle = supportsAdoptingStyleSheets
    ? (s) => s
    : (s) => s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;
//# sourceMappingURL=css-tag.js.map
;// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/development/reactive-element.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a, _b, _c;
var _d;
/**
 * Use this module if you want to create your own base class extending
 * {@link ReactiveElement}.
 * @packageDocumentation
 */


const DEV_MODE = true;
let requestUpdateThenable;
let issueWarning;
const trustedTypes = window
    .trustedTypes;
// Temporary workaround for https://crbug.com/993268
// Currently, any attribute starting with "on" is considered to be a
// TrustedScript source. Such boolean attributes must be set to the equivalent
// trusted emptyScript value.
const emptyStringForBooleanAttribute = trustedTypes
    ? trustedTypes.emptyScript
    : '';
const polyfillSupport = DEV_MODE
    ? window.reactiveElementPolyfillSupportDevMode
    : window.reactiveElementPolyfillSupport;
if (DEV_MODE) {
    // Ensure warnings are issued only 1x, even if multiple versions of Lit
    // are loaded.
    const issuedWarnings = ((_a = globalThis.litIssuedWarnings) !== null && _a !== void 0 ? _a : (globalThis.litIssuedWarnings = new Set()));
    // Issue a warning, if we haven't already.
    issueWarning = (code, warning) => {
        warning += ` See https://lit.dev/msg/${code} for more information.`;
        if (!issuedWarnings.has(warning)) {
            console.warn(warning);
            issuedWarnings.add(warning);
        }
    };
    issueWarning('dev-mode', `Lit is in dev mode. Not recommended for production!`);
    // Issue polyfill support warning.
    if (((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.inUse) && polyfillSupport === undefined) {
        issueWarning('polyfill-support-missing', `Shadow DOM is being polyfilled via \`ShadyDOM\` but ` +
            `the \`polyfill-support\` module has not been loaded.`);
    }
    requestUpdateThenable = (name) => ({
        then: (onfulfilled, _onrejected) => {
            issueWarning('request-update-promise', `The \`requestUpdate\` method should no longer return a Promise but ` +
                `does so on \`${name}\`. Use \`updateComplete\` instead.`);
            if (onfulfilled !== undefined) {
                onfulfilled(false);
            }
        },
    });
}
/**
 * Useful for visualizing and logging insights into what the Lit template system is doing.
 *
 * Compiled out of prod mode builds.
 */
const debugLogEvent = DEV_MODE
    ? (event) => {
        const shouldEmit = window
            .emitLitDebugLogEvents;
        if (!shouldEmit) {
            return;
        }
        window.dispatchEvent(new CustomEvent('lit-debug', {
            detail: event,
        }));
    }
    : undefined;
/*
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
 * replaced at compile time by the munged name for object[property]. We cannot
 * alias this function, so we have to use a small shim that has the same
 * behavior when not compiling.
 */
/*@__INLINE__*/
const JSCompiler_renameProperty = (prop, _obj) => prop;
const defaultConverter = {
    toAttribute(value, type) {
        switch (type) {
            case Boolean:
                value = value ? emptyStringForBooleanAttribute : null;
                break;
            case Object:
            case Array:
                // if the value is `null` or `undefined` pass this through
                // to allow removing/no change behavior.
                value = value == null ? value : JSON.stringify(value);
                break;
        }
        return value;
    },
    fromAttribute(value, type) {
        let fromValue = value;
        switch (type) {
            case Boolean:
                fromValue = value !== null;
                break;
            case Number:
                fromValue = value === null ? null : Number(value);
                break;
            case Object:
            case Array:
                // Do *not* generate exception when invalid JSON is set as elements
                // don't normally complain on being mis-configured.
                // TODO(sorvell): Do generate exception in *dev mode*.
                try {
                    // Assert to adhere to Bazel's "must type assert JSON parse" rule.
                    fromValue = JSON.parse(value);
                }
                catch (e) {
                    fromValue = null;
                }
                break;
        }
        return fromValue;
    },
};
/**
 * Change function that returns true if `value` is different from `oldValue`.
 * This method is used as the default for a property's `hasChanged` function.
 */
const notEqual = (value, old) => {
    // This ensures (old==NaN, value==NaN) always returns false
    return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
    attribute: true,
    type: String,
    converter: defaultConverter,
    reflect: false,
    hasChanged: notEqual,
};
/**
 * The Closure JS Compiler doesn't currently have good support for static
 * property semantics where "this" is dynamic (e.g.
 * https://github.com/google/closure-compiler/issues/3177 and others) so we use
 * this hack to bypass any rewriting by the compiler.
 */
const finalized = 'finalized';
/**
 * Base element class which manages element properties and attributes. When
 * properties change, the `update` method is asynchronously called. This method
 * should be supplied by subclassers to render updates as desired.
 * @noInheritDoc
 */
class ReactiveElement extends HTMLElement {
    constructor() {
        super();
        this.__instanceProperties = new Map();
        /**
         * True if there is a pending update as a result of calling `requestUpdate()`.
         * Should only be read.
         * @category updates
         */
        this.isUpdatePending = false;
        /**
         * Is set to `true` after the first update. The element code cannot assume
         * that `renderRoot` exists before the element `hasUpdated`.
         * @category updates
         */
        this.hasUpdated = false;
        /**
         * Name of currently reflecting property
         */
        this.__reflectingProperty = null;
        this._initialize();
    }
    /**
     * Adds an initializer function to the class that is called during instance
     * construction.
     *
     * This is useful for code that runs against a `ReactiveElement`
     * subclass, such as a decorator, that needs to do work for each
     * instance, such as setting up a `ReactiveController`.
     *
     * ```ts
     * const myDecorator = (target: typeof ReactiveElement, key: string) => {
     *   target.addInitializer((instance: ReactiveElement) => {
     *     // This is run during construction of the element
     *     new MyController(instance);
     *   });
     * }
     * ```
     *
     * Decorating a field will then cause each instance to run an initializer
     * that adds a controller:
     *
     * ```ts
     * class MyElement extends LitElement {
     *   @myDecorator foo;
     * }
     * ```
     *
     * Initializers are stored per-constructor. Adding an initializer to a
     * subclass does not add it to a superclass. Since initializers are run in
     * constructors, initializers will run in order of the class hierarchy,
     * starting with superclasses and progressing to the instance's class.
     *
     * @nocollapse
     */
    static addInitializer(initializer) {
        var _a;
        (_a = this._initializers) !== null && _a !== void 0 ? _a : (this._initializers = []);
        this._initializers.push(initializer);
    }
    /**
     * Returns a list of attributes corresponding to the registered properties.
     * @nocollapse
     * @category attributes
     */
    static get observedAttributes() {
        // note: piggy backing on this to ensure we're finalized.
        this.finalize();
        const attributes = [];
        // Use forEach so this works even if for/of loops are compiled to for loops
        // expecting arrays
        this.elementProperties.forEach((v, p) => {
            const attr = this.__attributeNameForProperty(p, v);
            if (attr !== undefined) {
                this.__attributeToPropertyMap.set(attr, p);
                attributes.push(attr);
            }
        });
        return attributes;
    }
    /**
     * Creates a property accessor on the element prototype if one does not exist
     * and stores a {@linkcode PropertyDeclaration} for the property with the
     * given options. The property setter calls the property's `hasChanged`
     * property option or uses a strict identity check to determine whether or not
     * to request an update.
     *
     * This method may be overridden to customize properties; however,
     * when doing so, it's important to call `super.createProperty` to ensure
     * the property is setup correctly. This method calls
     * `getPropertyDescriptor` internally to get a descriptor to install.
     * To customize what properties do when they are get or set, override
     * `getPropertyDescriptor`. To customize the options for a property,
     * implement `createProperty` like this:
     *
     * ```ts
     * static createProperty(name, options) {
     *   options = Object.assign(options, {myOption: true});
     *   super.createProperty(name, options);
     * }
     * ```
     *
     * @nocollapse
     * @category properties
     */
    static createProperty(name, options = defaultPropertyDeclaration) {
        var _a;
        // if this is a state property, force the attribute to false.
        if (options.state) {
            // Cast as any since this is readonly.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            options.attribute = false;
        }
        // Note, since this can be called by the `@property` decorator which
        // is called before `finalize`, we ensure finalization has been kicked off.
        this.finalize();
        this.elementProperties.set(name, options);
        // Do not generate an accessor if the prototype already has one, since
        // it would be lost otherwise and that would never be the user's intention;
        // Instead, we expect users to call `requestUpdate` themselves from
        // user-defined accessors. Note that if the super has an accessor we will
        // still overwrite it
        if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {
            const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
            const descriptor = this.getPropertyDescriptor(name, key, options);
            if (descriptor !== undefined) {
                Object.defineProperty(this.prototype, name, descriptor);
                if (DEV_MODE) {
                    // If this class doesn't have its own set, create one and initialize
                    // with the values in the set from the nearest ancestor class, if any.
                    if (!this.hasOwnProperty('__reactivePropertyKeys')) {
                        this.__reactivePropertyKeys = new Set((_a = this.__reactivePropertyKeys) !== null && _a !== void 0 ? _a : []);
                    }
                    this.__reactivePropertyKeys.add(name);
                }
            }
        }
    }
    /**
     * Returns a property descriptor to be defined on the given named property.
     * If no descriptor is returned, the property will not become an accessor.
     * For example,
     *
     * ```ts
     * class MyElement extends LitElement {
     *   static getPropertyDescriptor(name, key, options) {
     *     const defaultDescriptor =
     *         super.getPropertyDescriptor(name, key, options);
     *     const setter = defaultDescriptor.set;
     *     return {
     *       get: defaultDescriptor.get,
     *       set(value) {
     *         setter.call(this, value);
     *         // custom action.
     *       },
     *       configurable: true,
     *       enumerable: true
     *     }
     *   }
     * }
     * ```
     *
     * @nocollapse
     * @category properties
     */
    static getPropertyDescriptor(name, key, options) {
        return {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            get() {
                return this[key];
            },
            set(value) {
                const oldValue = this[name];
                this[key] = value;
                this.requestUpdate(name, oldValue, options);
            },
            configurable: true,
            enumerable: true,
        };
    }
    /**
     * Returns the property options associated with the given property.
     * These options are defined with a `PropertyDeclaration` via the `properties`
     * object or the `@property` decorator and are registered in
     * `createProperty(...)`.
     *
     * Note, this method should be considered "final" and not overridden. To
     * customize the options for a given property, override
     * {@linkcode createProperty}.
     *
     * @nocollapse
     * @final
     * @category properties
     */
    static getPropertyOptions(name) {
        return this.elementProperties.get(name) || defaultPropertyDeclaration;
    }
    /**
     * Creates property accessors for registered properties, sets up element
     * styling, and ensures any superclasses are also finalized. Returns true if
     * the element was finalized.
     * @nocollapse
     */
    static finalize() {
        if (this.hasOwnProperty(finalized)) {
            return false;
        }
        this[finalized] = true;
        // finalize any superclasses
        const superCtor = Object.getPrototypeOf(this);
        superCtor.finalize();
        this.elementProperties = new Map(superCtor.elementProperties);
        // initialize Map populated in observedAttributes
        this.__attributeToPropertyMap = new Map();
        // make any properties
        // Note, only process "own" properties since this element will inherit
        // any properties defined on the superClass, and finalization ensures
        // the entire prototype chain is finalized.
        if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
            const props = this.properties;
            // support symbols in properties (IE11 does not support this)
            const propKeys = [
                ...Object.getOwnPropertyNames(props),
                ...Object.getOwnPropertySymbols(props),
            ];
            // This for/of is ok because propKeys is an array
            for (const p of propKeys) {
                // note, use of `any` is due to TypeScript lack of support for symbol in
                // index types
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this.createProperty(p, props[p]);
            }
        }
        this.elementStyles = this.finalizeStyles(this.styles);
        // DEV mode warnings
        if (DEV_MODE) {
            const warnRemovedOrRenamed = (name, renamed = false) => {
                if (this.prototype.hasOwnProperty(name)) {
                    issueWarning(renamed ? 'renamed-api' : 'removed-api', `\`${name}\` is implemented on class ${this.name}. It ` +
                        `has been ${renamed ? 'renamed' : 'removed'} ` +
                        `in this version of LitElement.`);
                }
            };
            warnRemovedOrRenamed('initialize');
            warnRemovedOrRenamed('requestUpdateInternal');
            warnRemovedOrRenamed('_getUpdateComplete', true);
        }
        return true;
    }
    /**
     * Takes the styles the user supplied via the `static styles` property and
     * returns the array of styles to apply to the element.
     * Override this method to integrate into a style management system.
     *
     * Styles are deduplicated preserving the _last_ instance in the list. This
     * is a performance optimization to avoid duplicated styles that can occur
     * especially when composing via subclassing. The last item is kept to try
     * to preserve the cascade order with the assumption that it's most important
     * that last added styles override previous styles.
     *
     * @nocollapse
     * @category styles
     */
    static finalizeStyles(styles) {
        const elementStyles = [];
        if (Array.isArray(styles)) {
            // Dedupe the flattened array in reverse order to preserve the last items.
            // Casting to Array<unknown> works around TS error that
            // appears to come from trying to flatten a type CSSResultArray.
            const set = new Set(styles.flat(Infinity).reverse());
            // Then preserve original order by adding the set items in reverse order.
            for (const s of set) {
                elementStyles.unshift(getCompatibleStyle(s));
            }
        }
        else if (styles !== undefined) {
            elementStyles.push(getCompatibleStyle(styles));
        }
        return elementStyles;
    }
    /**
     * Returns the property name for the given attribute `name`.
     * @nocollapse
     */
    static __attributeNameForProperty(name, options) {
        const attribute = options.attribute;
        return attribute === false
            ? undefined
            : typeof attribute === 'string'
                ? attribute
                : typeof name === 'string'
                    ? name.toLowerCase()
                    : undefined;
    }
    /**
     * Internal only override point for customizing work done when elements
     * are constructed.
     *
     * @internal
     */
    _initialize() {
        var _a;
        this.__updatePromise = new Promise((res) => (this.enableUpdating = res));
        this._$changedProperties = new Map();
        this.__saveInstanceProperties();
        // ensures first update will be caught by an early access of
        // `updateComplete`
        this.requestUpdate();
        (_a = this.constructor._initializers) === null || _a === void 0 ? void 0 : _a.forEach((i) => i(this));
    }
    /**
     * Registers a `ReactiveController` to participate in the element's reactive
     * update cycle. The element automatically calls into any registered
     * controllers during its lifecycle callbacks.
     *
     * If the element is connected when `addController()` is called, the
     * controller's `hostConnected()` callback will be immediately called.
     * @category controllers
     */
    addController(controller) {
        var _a, _b;
        ((_a = this.__controllers) !== null && _a !== void 0 ? _a : (this.__controllers = [])).push(controller);
        // If a controller is added after the element has been connected,
        // call hostConnected. Note, re-using existence of `renderRoot` here
        // (which is set in connectedCallback) to avoid the need to track a
        // first connected state.
        if (this.renderRoot !== undefined && this.isConnected) {
            (_b = controller.hostConnected) === null || _b === void 0 ? void 0 : _b.call(controller);
        }
    }
    /**
     * Removes a `ReactiveController` from the element.
     * @category controllers
     */
    removeController(controller) {
        var _a;
        // Note, if the indexOf is -1, the >>> will flip the sign which makes the
        // splice do nothing.
        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.splice(this.__controllers.indexOf(controller) >>> 0, 1);
    }
    /**
     * Fixes any properties set on the instance before upgrade time.
     * Otherwise these would shadow the accessor and break these properties.
     * The properties are stored in a Map which is played back after the
     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
     * (<=41), properties created for native platform properties like (`id` or
     * `name`) may not have default values set in the element constructor. On
     * these browsers native properties appear on instances and therefore their
     * default value will overwrite any element default (e.g. if the element sets
     * this.id = 'id' in the constructor, the 'id' will become '' since this is
     * the native platform default).
     */
    __saveInstanceProperties() {
        // Use forEach so this works even if for/of loops are compiled to for loops
        // expecting arrays
        this.constructor.elementProperties.forEach((_v, p) => {
            if (this.hasOwnProperty(p)) {
                this.__instanceProperties.set(p, this[p]);
                delete this[p];
            }
        });
    }
    /**
     * Returns the node into which the element should render and by default
     * creates and returns an open shadowRoot. Implement to customize where the
     * element's DOM is rendered. For example, to render into the element's
     * childNodes, return `this`.
     *
     * @return Returns a node into which to render.
     * @category rendering
     */
    createRenderRoot() {
        var _a;
        const renderRoot = (_a = this.shadowRoot) !== null && _a !== void 0 ? _a : this.attachShadow(this.constructor.shadowRootOptions);
        adoptStyles(renderRoot, this.constructor.elementStyles);
        return renderRoot;
    }
    /**
     * On first connection, creates the element's renderRoot, sets up
     * element styling, and enables updating.
     * @category lifecycle
     */
    connectedCallback() {
        var _a;
        // create renderRoot before first update.
        if (this.renderRoot === undefined) {
            this.renderRoot = this.createRenderRoot();
        }
        this.enableUpdating(true);
        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostConnected) === null || _a === void 0 ? void 0 : _a.call(c); });
    }
    /**
     * Note, this method should be considered final and not overridden. It is
     * overridden on the element instance with a function that triggers the first
     * update.
     * @category updates
     */
    enableUpdating(_requestedUpdate) { }
    /**
     * Allows for `super.disconnectedCallback()` in extensions while
     * reserving the possibility of making non-breaking feature additions
     * when disconnecting at some point in the future.
     * @category lifecycle
     */
    disconnectedCallback() {
        var _a;
        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostDisconnected) === null || _a === void 0 ? void 0 : _a.call(c); });
    }
    /**
     * Synchronizes property values when attributes change.
     *
     * Specifically, when an attribute is set, the corresponding property is set.
     * You should rarely need to implement this callback. If this method is
     * overridden, `super.attributeChangedCallback(name, _old, value)` must be
     * called.
     *
     * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)
     * on MDN for more information about the `attributeChangedCallback`.
     * @category attributes
     */
    attributeChangedCallback(name, _old, value) {
        this._$attributeToProperty(name, value);
    }
    __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
        var _a, _b;
        const attr = this.constructor.__attributeNameForProperty(name, options);
        if (attr !== undefined && options.reflect === true) {
            const toAttribute = (_b = (_a = options.converter) === null || _a === void 0 ? void 0 : _a.toAttribute) !== null && _b !== void 0 ? _b : defaultConverter.toAttribute;
            const attrValue = toAttribute(value, options.type);
            if (DEV_MODE &&
                this.constructor.enabledWarnings.indexOf('migration') >= 0 &&
                attrValue === undefined) {
                issueWarning('undefined-attribute-value', `The attribute value for the ${name} property is ` +
                    `undefined on element ${this.localName}. The attribute will be ` +
                    `removed, but in the previous version of \`ReactiveElement\`, ` +
                    `the attribute would not have changed.`);
            }
            // Track if the property is being reflected to avoid
            // setting the property again via `attributeChangedCallback`. Note:
            // 1. this takes advantage of the fact that the callback is synchronous.
            // 2. will behave incorrectly if multiple attributes are in the reaction
            // stack at time of calling. However, since we process attributes
            // in `update` this should not be possible (or an extreme corner case
            // that we'd like to discover).
            // mark state reflecting
            this.__reflectingProperty = name;
            if (attrValue == null) {
                this.removeAttribute(attr);
            }
            else {
                this.setAttribute(attr, attrValue);
            }
            // mark state not reflecting
            this.__reflectingProperty = null;
        }
    }
    /** @internal */
    _$attributeToProperty(name, value) {
        var _a, _b, _c;
        const ctor = this.constructor;
        // Note, hint this as an `AttributeMap` so closure clearly understands
        // the type; it has issues with tracking types through statics
        const propName = ctor.__attributeToPropertyMap.get(name);
        // Use tracking info to avoid reflecting a property value to an attribute
        // if it was just set because the attribute changed.
        if (propName !== undefined && this.__reflectingProperty !== propName) {
            const options = ctor.getPropertyOptions(propName);
            const converter = options.converter;
            const fromAttribute = (_c = (_b = (_a = converter) === null || _a === void 0 ? void 0 : _a.fromAttribute) !== null && _b !== void 0 ? _b : (typeof converter === 'function'
                ? converter
                : null)) !== null && _c !== void 0 ? _c : defaultConverter.fromAttribute;
            // mark state reflecting
            this.__reflectingProperty = propName;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this[propName] = fromAttribute(value, options.type);
            // mark state not reflecting
            this.__reflectingProperty = null;
        }
    }
    /**
     * Requests an update which is processed asynchronously. This should be called
     * when an element should update based on some state not triggered by setting
     * a reactive property. In this case, pass no arguments. It should also be
     * called when manually implementing a property setter. In this case, pass the
     * property `name` and `oldValue` to ensure that any configured property
     * options are honored.
     *
     * @param name name of requesting property
     * @param oldValue old value of requesting property
     * @param options property options to use instead of the previously
     *     configured options
     * @category updates
     */
    requestUpdate(name, oldValue, options) {
        let shouldRequestUpdate = true;
        // If we have a property key, perform property update steps.
        if (name !== undefined) {
            options =
                options ||
                    this.constructor.getPropertyOptions(name);
            const hasChanged = options.hasChanged || notEqual;
            if (hasChanged(this[name], oldValue)) {
                if (!this._$changedProperties.has(name)) {
                    this._$changedProperties.set(name, oldValue);
                }
                // Add to reflecting properties set.
                // Note, it's important that every change has a chance to add the
                // property to `_reflectingProperties`. This ensures setting
                // attribute + property reflects correctly.
                if (options.reflect === true && this.__reflectingProperty !== name) {
                    if (this.__reflectingProperties === undefined) {
                        this.__reflectingProperties = new Map();
                    }
                    this.__reflectingProperties.set(name, options);
                }
            }
            else {
                // Abort the request if the property should not be considered changed.
                shouldRequestUpdate = false;
            }
        }
        if (!this.isUpdatePending && shouldRequestUpdate) {
            this.__updatePromise = this.__enqueueUpdate();
        }
        // Note, since this no longer returns a promise, in dev mode we return a
        // thenable which warns if it's called.
        return DEV_MODE
            ? requestUpdateThenable(this.localName)
            : undefined;
    }
    /**
     * Sets up the element to asynchronously update.
     */
    async __enqueueUpdate() {
        this.isUpdatePending = true;
        try {
            // Ensure any previous update has resolved before updating.
            // This `await` also ensures that property changes are batched.
            await this.__updatePromise;
        }
        catch (e) {
            // Refire any previous errors async so they do not disrupt the update
            // cycle. Errors are refired so developers have a chance to observe
            // them, and this can be done by implementing
            // `window.onunhandledrejection`.
            Promise.reject(e);
        }
        const result = this.scheduleUpdate();
        // If `scheduleUpdate` returns a Promise, we await it. This is done to
        // enable coordinating updates with a scheduler. Note, the result is
        // checked to avoid delaying an additional microtask unless we need to.
        if (result != null) {
            await result;
        }
        return !this.isUpdatePending;
    }
    /**
     * Schedules an element update. You can override this method to change the
     * timing of updates by returning a Promise. The update will await the
     * returned Promise, and you should resolve the Promise to allow the update
     * to proceed. If this method is overridden, `super.scheduleUpdate()`
     * must be called.
     *
     * For instance, to schedule updates to occur just before the next frame:
     *
     * ```ts
     * override protected async scheduleUpdate(): Promise<unknown> {
     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
     *   super.scheduleUpdate();
     * }
     * ```
     * @category updates
     */
    scheduleUpdate() {
        return this.performUpdate();
    }
    /**
     * Performs an element update. Note, if an exception is thrown during the
     * update, `firstUpdated` and `updated` will not be called.
     *
     * Call `performUpdate()` to immediately process a pending update. This should
     * generally not be needed, but it can be done in rare cases when you need to
     * update synchronously.
     *
     * Note: To ensure `performUpdate()` synchronously completes a pending update,
     * it should not be overridden. In LitElement 2.x it was suggested to override
     * `performUpdate()` to also customizing update scheduling. Instead, you should now
     * override `scheduleUpdate()`. For backwards compatibility with LitElement 2.x,
     * scheduling updates via `performUpdate()` continues to work, but will make
     * also calling `performUpdate()` to synchronously process updates difficult.
     *
     * @category updates
     */
    performUpdate() {
        var _a, _b;
        // Abort any update if one is not pending when this is called.
        // This can happen if `performUpdate` is called early to "flush"
        // the update.
        if (!this.isUpdatePending) {
            return;
        }
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({ kind: 'update' });
        // create renderRoot before first update.
        if (!this.hasUpdated) {
            // Produce warning if any class properties are shadowed by class fields
            if (DEV_MODE) {
                const shadowedProperties = [];
                (_a = this.constructor.__reactivePropertyKeys) === null || _a === void 0 ? void 0 : _a.forEach((p) => {
                    var _a;
                    if (this.hasOwnProperty(p) && !((_a = this.__instanceProperties) === null || _a === void 0 ? void 0 : _a.has(p))) {
                        shadowedProperties.push(p);
                    }
                });
                if (shadowedProperties.length) {
                    throw new Error(`The following properties on element ${this.localName} will not ` +
                        `trigger updates as expected because they are set using class ` +
                        `fields: ${shadowedProperties.join(', ')}. ` +
                        `Native class fields and some compiled output will overwrite ` +
                        `accessors used for detecting changes. See ` +
                        `https://lit.dev/msg/class-field-shadowing ` +
                        `for more information.`);
                }
            }
        }
        // Mixin instance properties once, if they exist.
        if (this.__instanceProperties) {
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.__instanceProperties.forEach((v, p) => (this[p] = v));
            this.__instanceProperties = undefined;
        }
        let shouldUpdate = false;
        const changedProperties = this._$changedProperties;
        try {
            shouldUpdate = this.shouldUpdate(changedProperties);
            if (shouldUpdate) {
                this.willUpdate(changedProperties);
                (_b = this.__controllers) === null || _b === void 0 ? void 0 : _b.forEach((c) => { var _a; return (_a = c.hostUpdate) === null || _a === void 0 ? void 0 : _a.call(c); });
                this.update(changedProperties);
            }
            else {
                this.__markUpdated();
            }
        }
        catch (e) {
            // Prevent `firstUpdated` and `updated` from running when there's an
            // update exception.
            shouldUpdate = false;
            // Ensure element can accept additional updates after an exception.
            this.__markUpdated();
            throw e;
        }
        // The update is no longer considered pending and further updates are now allowed.
        if (shouldUpdate) {
            this._$didUpdate(changedProperties);
        }
    }
    /**
     * Invoked before `update()` to compute values needed during the update.
     *
     * Implement `willUpdate` to compute property values that depend on other
     * properties and are used in the rest of the update process.
     *
     * ```ts
     * willUpdate(changedProperties) {
     *   // only need to check changed properties for an expensive computation.
     *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
     *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
     *   }
     * }
     *
     * render() {
     *   return html`SHA: ${this.sha}`;
     * }
     * ```
     *
     * @category updates
     */
    willUpdate(_changedProperties) { }
    // Note, this is an override point for polyfill-support.
    // @internal
    _$didUpdate(changedProperties) {
        var _a;
        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostUpdated) === null || _a === void 0 ? void 0 : _a.call(c); });
        if (!this.hasUpdated) {
            this.hasUpdated = true;
            this.firstUpdated(changedProperties);
        }
        this.updated(changedProperties);
        if (DEV_MODE &&
            this.isUpdatePending &&
            this.constructor.enabledWarnings.indexOf('change-in-update') >= 0) {
            issueWarning('change-in-update', `Element ${this.localName} scheduled an update ` +
                `(generally because a property was set) ` +
                `after an update completed, causing a new update to be scheduled. ` +
                `This is inefficient and should be avoided unless the next update ` +
                `can only be scheduled as a side effect of the previous update.`);
        }
    }
    __markUpdated() {
        this._$changedProperties = new Map();
        this.isUpdatePending = false;
    }
    /**
     * Returns a Promise that resolves when the element has completed updating.
     * The Promise value is a boolean that is `true` if the element completed the
     * update without triggering another update. The Promise result is `false` if
     * a property was set inside `updated()`. If the Promise is rejected, an
     * exception was thrown during the update.
     *
     * To await additional asynchronous work, override the `getUpdateComplete`
     * method. For example, it is sometimes useful to await a rendered element
     * before fulfilling this Promise. To do this, first await
     * `super.getUpdateComplete()`, then any subsequent state.
     *
     * @return A promise of a boolean that resolves to true if the update completed
     *     without triggering another update.
     * @category updates
     */
    get updateComplete() {
        return this.getUpdateComplete();
    }
    /**
     * Override point for the `updateComplete` promise.
     *
     * It is not safe to override the `updateComplete` getter directly due to a
     * limitation in TypeScript which means it is not possible to call a
     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
     * This method should be overridden instead. For example:
     *
     * ```ts
     * class MyElement extends LitElement {
     *   override async getUpdateComplete() {
     *     const result = await super.getUpdateComplete();
     *     await this._myChild.updateComplete;
     *     return result;
     *   }
     * }
     * ```
     *
     * @return A promise of a boolean that resolves to true if the update completed
     *     without triggering another update.
     * @category updates
     */
    getUpdateComplete() {
        return this.__updatePromise;
    }
    /**
     * Controls whether or not `update()` should be called when the element requests
     * an update. By default, this method always returns `true`, but this can be
     * customized to control when to update.
     *
     * @param _changedProperties Map of changed properties with old values
     * @category updates
     */
    shouldUpdate(_changedProperties) {
        return true;
    }
    /**
     * Updates the element. This method reflects property values to attributes.
     * It can be overridden to render and keep updated element DOM.
     * Setting properties inside this method will *not* trigger
     * another update.
     *
     * @param _changedProperties Map of changed properties with old values
     * @category updates
     */
    update(_changedProperties) {
        if (this.__reflectingProperties !== undefined) {
            // Use forEach so this works even if for/of loops are compiled to for
            // loops expecting arrays
            this.__reflectingProperties.forEach((v, k) => this.__propertyToAttribute(k, this[k], v));
            this.__reflectingProperties = undefined;
        }
        this.__markUpdated();
    }
    /**
     * Invoked whenever the element is updated. Implement to perform
     * post-updating tasks via DOM APIs, for example, focusing an element.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * @param _changedProperties Map of changed properties with old values
     * @category updates
     */
    updated(_changedProperties) { }
    /**
     * Invoked when the element is first updated. Implement to perform one time
     * work on the element after update.
     *
     * ```ts
     * firstUpdated() {
     *   this.renderRoot.getElementById('my-text-area').focus();
     * }
     * ```
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * @param _changedProperties Map of changed properties with old values
     * @category updates
     */
    firstUpdated(_changedProperties) { }
}
_d = finalized;
/**
 * Marks class as having finished creating properties.
 */
ReactiveElement[_d] = true;
/**
 * Memoized list of all element properties, including any superclass properties.
 * Created lazily on user subclasses when finalizing the class.
 * @nocollapse
 * @category properties
 */
ReactiveElement.elementProperties = new Map();
/**
 * Memoized list of all element styles.
 * Created lazily on user subclasses when finalizing the class.
 * @nocollapse
 * @category styles
 */
ReactiveElement.elementStyles = [];
/**
 * Options used when calling `attachShadow`. Set this property to customize
 * the options for the shadowRoot; for example, to create a closed
 * shadowRoot: `{mode: 'closed'}`.
 *
 * Note, these options are used in `createRenderRoot`. If this method
 * is customized, options should be respected if possible.
 * @nocollapse
 * @category rendering
 */
ReactiveElement.shadowRootOptions = { mode: 'open' };
// Apply polyfills if available
polyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport({ ReactiveElement });
// Dev mode warnings...
if (DEV_MODE) {
    // Default warning set.
    ReactiveElement.enabledWarnings = ['change-in-update'];
    const ensureOwnWarnings = function (ctor) {
        if (!ctor.hasOwnProperty(JSCompiler_renameProperty('enabledWarnings', ctor))) {
            ctor.enabledWarnings = ctor.enabledWarnings.slice();
        }
    };
    ReactiveElement.enableWarning = function (warning) {
        ensureOwnWarnings(this);
        if (this.enabledWarnings.indexOf(warning) < 0) {
            this.enabledWarnings.push(warning);
        }
    };
    ReactiveElement.disableWarning = function (warning) {
        ensureOwnWarnings(this);
        const i = this.enabledWarnings.indexOf(warning);
        if (i >= 0) {
            this.enabledWarnings.splice(i, 1);
        }
    };
}
// IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for ReactiveElement usage.
((_c = globalThis.reactiveElementVersions) !== null && _c !== void 0 ? _c : (globalThis.reactiveElementVersions = [])).push('1.3.2');
if (DEV_MODE && globalThis.reactiveElementVersions.length > 1) {
    issueWarning('multiple-versions', `Multiple versions of Lit loaded. Loading multiple versions ` +
        `is not recommended.`);
}
//# sourceMappingURL=reactive-element.js.map
// EXTERNAL MODULE: ./node_modules/lit-html/development/lit-html.js
var lit_html = __webpack_require__("./node_modules/lit-html/development/lit-html.js");
;// CONCATENATED MODULE: ./node_modules/lit-element/development/lit-element.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var lit_element_a, lit_element_b, lit_element_c;
/**
 * The main LitElement module, which defines the {@linkcode LitElement} base
 * class and related APIs.
 *
 *  LitElement components can define a template and a set of observed
 * properties. Changing an observed property triggers a re-render of the
 * element.
 *
 *  Import {@linkcode LitElement} and {@linkcode html} from this module to
 * create a component:
 *
 *  ```js
 * import {LitElement, html} from 'lit-element';
 *
 * class MyElement extends LitElement {
 *
 *   // Declare observed properties
 *   static get properties() {
 *     return {
 *       adjective: {}
 *     }
 *   }
 *
 *   constructor() {
 *     this.adjective = 'awesome';
 *   }
 *
 *   // Define the element's template
 *   render() {
 *     return html`<p>your ${adjective} template here</p>`;
 *   }
 * }
 *
 * customElements.define('my-element', MyElement);
 * ```
 *
 * `LitElement` extends {@linkcode ReactiveElement} and adds lit-html
 * templating. The `ReactiveElement` class is provided for users that want to
 * build their own custom element base classes that don't use lit-html.
 *
 * @packageDocumentation
 */




// For backwards compatibility export ReactiveElement as UpdatingElement. Note,
// IE transpilation requires exporting like this.
const UpdatingElement = ReactiveElement;
const lit_element_DEV_MODE = true;
let lit_element_issueWarning;
if (lit_element_DEV_MODE) {
    // Ensure warnings are issued only 1x, even if multiple versions of Lit
    // are loaded.
    const issuedWarnings = ((lit_element_a = globalThis.litIssuedWarnings) !== null && lit_element_a !== void 0 ? lit_element_a : (globalThis.litIssuedWarnings = new Set()));
    // Issue a warning, if we haven't already.
    lit_element_issueWarning = (code, warning) => {
        warning += ` See https://lit.dev/msg/${code} for more information.`;
        if (!issuedWarnings.has(warning)) {
            console.warn(warning);
            issuedWarnings.add(warning);
        }
    };
}
/**
 * Base element class that manages element properties and attributes, and
 * renders a lit-html template.
 *
 * To define a component, subclass `LitElement` and implement a
 * `render` method to provide the component's template. Define properties
 * using the {@linkcode LitElement.properties properties} property or the
 * {@linkcode property} decorator.
 */
class LitElement extends ReactiveElement {
    constructor() {
        super(...arguments);
        /**
         * @category rendering
         */
        this.renderOptions = { host: this };
        this.__childPart = undefined;
    }
    /**
     * @category rendering
     */
    createRenderRoot() {
        var _a;
        var _b;
        const renderRoot = super.createRenderRoot();
        // When adoptedStyleSheets are shimmed, they are inserted into the
        // shadowRoot by createRenderRoot. Adjust the renderBefore node so that
        // any styles in Lit content render before adoptedStyleSheets. This is
        // important so that adoptedStyleSheets have precedence over styles in
        // the shadowRoot.
        (_a = (_b = this.renderOptions).renderBefore) !== null && _a !== void 0 ? _a : (_b.renderBefore = renderRoot.firstChild);
        return renderRoot;
    }
    /**
     * Updates the element. This method reflects property values to attributes
     * and calls `render` to render DOM via lit-html. Setting properties inside
     * this method will *not* trigger another update.
     * @param changedProperties Map of changed properties with old values
     * @category updates
     */
    update(changedProperties) {
        // Setting properties in `render` should not trigger an update. Since
        // updates are allowed after super.update, it's important to call `render`
        // before that.
        const value = this.render();
        if (!this.hasUpdated) {
            this.renderOptions.isConnected = this.isConnected;
        }
        super.update(changedProperties);
        this.__childPart = (0,lit_html.render)(value, this.renderRoot, this.renderOptions);
    }
    /**
     * Invoked when the component is added to the document's DOM.
     *
     * In `connectedCallback()` you should setup tasks that should only occur when
     * the element is connected to the document. The most common of these is
     * adding event listeners to nodes external to the element, like a keydown
     * event handler added to the window.
     *
     * ```ts
     * connectedCallback() {
     *   super.connectedCallback();
     *   addEventListener('keydown', this._handleKeydown);
     * }
     * ```
     *
     * Typically, anything done in `connectedCallback()` should be undone when the
     * element is disconnected, in `disconnectedCallback()`.
     *
     * @category lifecycle
     */
    connectedCallback() {
        var _a;
        super.connectedCallback();
        (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(true);
    }
    /**
     * Invoked when the component is removed from the document's DOM.
     *
     * This callback is the main signal to the element that it may no longer be
     * used. `disconnectedCallback()` should ensure that nothing is holding a
     * reference to the element (such as event listeners added to nodes external
     * to the element), so that it is free to be garbage collected.
     *
     * ```ts
     * disconnectedCallback() {
     *   super.disconnectedCallback();
     *   window.removeEventListener('keydown', this._handleKeydown);
     * }
     * ```
     *
     * An element may be re-connected after being disconnected.
     *
     * @category lifecycle
     */
    disconnectedCallback() {
        var _a;
        super.disconnectedCallback();
        (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(false);
    }
    /**
     * Invoked on each update to perform rendering tasks. This method may return
     * any value renderable by lit-html's `ChildPart` - typically a
     * `TemplateResult`. Setting properties inside this method will *not* trigger
     * the element to update.
     * @category rendering
     */
    render() {
        return lit_html.noChange;
    }
}
/**
 * Ensure this class is marked as `finalized` as an optimization ensuring
 * it will not needlessly try to `finalize`.
 *
 * Note this property name is a string to prevent breaking Closure JS Compiler
 * optimizations. See @lit/reactive-element for more information.
 */
LitElement['finalized'] = true;
// This property needs to remain unminified.
LitElement['_$litElement$'] = true;
// Install hydration if available
(lit_element_b = globalThis.litElementHydrateSupport) === null || lit_element_b === void 0 ? void 0 : lit_element_b.call(globalThis, { LitElement });
// Apply polyfills if available
const lit_element_polyfillSupport = lit_element_DEV_MODE
    ? globalThis.litElementPolyfillSupportDevMode
    : globalThis.litElementPolyfillSupport;
lit_element_polyfillSupport === null || lit_element_polyfillSupport === void 0 ? void 0 : lit_element_polyfillSupport({ LitElement });
// DEV mode warnings
if (lit_element_DEV_MODE) {
    /* eslint-disable @typescript-eslint/no-explicit-any */
    // Note, for compatibility with closure compilation, this access
    // needs to be as a string property index.
    LitElement['finalize'] = function () {
        const finalized = ReactiveElement.finalize.call(this);
        if (!finalized) {
            return false;
        }
        const warnRemovedOrRenamed = (obj, name, renamed = false) => {
            if (obj.hasOwnProperty(name)) {
                const ctorName = (typeof obj === 'function' ? obj : obj.constructor)
                    .name;
                lit_element_issueWarning(renamed ? 'renamed-api' : 'removed-api', `\`${name}\` is implemented on class ${ctorName}. It ` +
                    `has been ${renamed ? 'renamed' : 'removed'} ` +
                    `in this version of LitElement.`);
            }
        };
        warnRemovedOrRenamed(this, 'render');
        warnRemovedOrRenamed(this, 'getStyles', true);
        warnRemovedOrRenamed(this.prototype, 'adoptStyles');
        return true;
    };
    /* eslint-enable @typescript-eslint/no-explicit-any */
}
/**
 * END USERS SHOULD NOT RELY ON THIS OBJECT.
 *
 * Private exports for use by other Lit packages, not intended for use by
 * external users.
 *
 * We currently do not make a mangled rollup build of the lit-ssr code. In order
 * to keep a number of (otherwise private) top-level exports  mangled in the
 * client side code, we export a _$LE object containing those members (or
 * helper methods for accessing private fields of those members), and then
 * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the
 * client-side code is being used in `dev` mode or `prod` mode.
 *
 * This has a unique name, to disambiguate it from private exports in
 * lit-html, since this module re-exports all of lit-html.
 *
 * @private
 */
const _$LE = {
    _$attributeToProperty: (el, name, value) => {
        // eslint-disable-next-line
        el._$attributeToProperty(name, value);
    },
    // eslint-disable-next-line
    _$changedProperties: (el) => el._$changedProperties,
};
// IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for LitElement usage.
((lit_element_c = globalThis.litElementVersions) !== null && lit_element_c !== void 0 ? lit_element_c : (globalThis.litElementVersions = [])).push('3.2.0');
if (lit_element_DEV_MODE && globalThis.litElementVersions.length > 1) {
    lit_element_issueWarning('multiple-versions', `Multiple versions of Lit loaded. Loading multiple versions ` +
        `is not recommended.`);
}
//# sourceMappingURL=lit-element.js.map
;// CONCATENATED MODULE: ./node_modules/lit/index.js

//# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/development/decorators/property.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const standardProperty = (options, element) => {
    // When decorating an accessor, pass it through and add property metadata.
    // Note, the `hasOwnProperty` check in `createProperty` ensures we don't
    // stomp over the user's accessor.
    if (element.kind === 'method' &&
        element.descriptor &&
        !('value' in element.descriptor)) {
        return {
            ...element,
            finisher(clazz) {
                clazz.createProperty(element.key, options);
            },
        };
    }
    else {
        // createProperty() takes care of defining the property, but we still
        // must return some kind of descriptor, so return a descriptor for an
        // unused prototype field. The finisher calls createProperty().
        return {
            kind: 'field',
            key: Symbol(),
            placement: 'own',
            descriptor: {},
            // store the original key so subsequent decorators have access to it.
            originalKey: element.key,
            // When @babel/plugin-proposal-decorators implements initializers,
            // do this instead of the initializer below. See:
            // https://github.com/babel/babel/issues/9260 extras: [
            //   {
            //     kind: 'initializer',
            //     placement: 'own',
            //     initializer: descriptor.initializer,
            //   }
            // ],
            initializer() {
                if (typeof element.initializer === 'function') {
                    this[element.key] = element.initializer.call(this);
                }
            },
            finisher(clazz) {
                clazz.createProperty(element.key, options);
            },
        };
    }
};
const legacyProperty = (options, proto, name) => {
    proto.constructor.createProperty(name, options);
};
/**
 * A property decorator which creates a reactive property that reflects a
 * corresponding attribute value. When a decorated property is set
 * the element will update and render. A {@linkcode PropertyDeclaration} may
 * optionally be supplied to configure property features.
 *
 * This decorator should only be used for public fields. As public fields,
 * properties should be considered as primarily settable by element users,
 * either via attribute or the property itself.
 *
 * Generally, properties that are changed by the element should be private or
 * protected fields and should use the {@linkcode state} decorator.
 *
 * However, sometimes element code does need to set a public property. This
 * should typically only be done in response to user interaction, and an event
 * should be fired informing the user; for example, a checkbox sets its
 * `checked` property when clicked and fires a `changed` event. Mutating public
 * properties should typically not be done for non-primitive (object or array)
 * properties. In other cases when an element needs to manage state, a private
 * property decorated via the {@linkcode state} decorator should be used. When
 * needed, state properties can be initialized via public properties to
 * facilitate complex interactions.
 *
 * ```ts
 * class MyElement {
 *   @property({ type: Boolean })
 *   clicked = false;
 * }
 * ```
 * @category Decorator
 * @ExportDecoratedItems
 */
function property(options) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (protoOrDescriptor, name) => name !== undefined
        ? legacyProperty(options, protoOrDescriptor, name)
        : standardProperty(options, protoOrDescriptor);
}
//# sourceMappingURL=property.js.map
;// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/development/decorators/base.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const legacyPrototypeMethod = (descriptor, proto, name) => {
    Object.defineProperty(proto, name, descriptor);
};
const standardPrototypeMethod = (descriptor, element) => ({
    kind: 'method',
    placement: 'prototype',
    key: element.key,
    descriptor,
});
/**
 * Helper for decorating a property that is compatible with both TypeScript
 * and Babel decorators. The optional `finisher` can be used to perform work on
 * the class. The optional `descriptor` should return a PropertyDescriptor
 * to install for the given property.
 *
 * @param finisher {function} Optional finisher method; receives the element
 * constructor and property key as arguments and has no return value.
 * @param descriptor {function} Optional descriptor method; receives the
 * property key as an argument and returns a property descriptor to define for
 * the given property.
 * @returns {ClassElement|void}
 */
const decorateProperty = ({ finisher, descriptor, }) => (protoOrDescriptor, name
// Note TypeScript requires the return type to be `void|any`
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) => {
    var _a;
    // TypeScript / Babel legacy mode
    if (name !== undefined) {
        const ctor = protoOrDescriptor
            .constructor;
        if (descriptor !== undefined) {
            Object.defineProperty(protoOrDescriptor, name, descriptor(name));
        }
        finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name);
        // Babel standard mode
    }
    else {
        // Note, the @property decorator saves `key` as `originalKey`
        // so try to use it here.
        const key = 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (_a = protoOrDescriptor.originalKey) !== null && _a !== void 0 ? _a : protoOrDescriptor.key;
        const info = descriptor != undefined
            ? {
                kind: 'method',
                placement: 'prototype',
                key,
                descriptor: descriptor(protoOrDescriptor.key),
            }
            : { ...protoOrDescriptor, key };
        if (finisher != undefined) {
            info.finisher = function (ctor) {
                finisher(ctor, key);
            };
        }
        return info;
    }
};
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/development/decorators/query-assigned-elements.js
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var query_assigned_elements_a;
/*
 * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all
 * property decorators (but not class decorators) in this file that have
 * an @ExportDecoratedItems annotation must be defined as a regular function,
 * not an arrow function.
 */

/**
 * A tiny module scoped polyfill for HTMLSlotElement.assignedElements.
 */
const slotAssignedElements = ((query_assigned_elements_a = window.HTMLSlotElement) === null || query_assigned_elements_a === void 0 ? void 0 : query_assigned_elements_a.prototype.assignedElements) != null
    ? (slot, opts) => slot.assignedElements(opts)
    : (slot, opts) => slot
        .assignedNodes(opts)
        .filter((node) => node.nodeType === Node.ELEMENT_NODE);
/**
 * A property decorator that converts a class property into a getter that
 * returns the `assignedElements` of the given `slot`. Provides a declarative
 * way to use
 * [`HTMLSlotElement.assignedElements`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/assignedElements).
 *
 * Can be passed an optional {@linkcode QueryAssignedElementsOptions} object.
 *
 * Example usage:
 * ```ts
 * class MyElement {
 *   @queryAssignedElements({ slot: 'list' })
 *   listItems!: Array<HTMLElement>;
 *   @queryAssignedElements()
 *   unnamedSlotEls!: Array<HTMLElement>;
 *
 *   render() {
 *     return html`
 *       <slot name="list"></slot>
 *       <slot></slot>
 *     `;
 *   }
 * }
 * ```
 *
 * Note, the type of this property should be annotated as `Array<HTMLElement>`.
 *
 * @category Decorator
 */
function queryAssignedElements(options) {
    const { slot, selector } = options !== null && options !== void 0 ? options : {};
    return decorateProperty({
        descriptor: (_name) => ({
            get() {
                var _a;
                const slotSelector = `slot${slot ? `[name=${slot}]` : ':not([name])'}`;
                const slotEl = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(slotSelector);
                const elements = slotEl != null ? slotAssignedElements(slotEl, options) : [];
                if (selector) {
                    return elements.filter((node) => node.matches(selector));
                }
                return elements;
            },
            enumerable: true,
            configurable: true,
        }),
    });
}
//# sourceMappingURL=query-assigned-elements.js.map
;// CONCATENATED MODULE: ./node_modules/@lit/reactive-element/development/decorators/query-assigned-nodes.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/*
 * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all
 * property decorators (but not class decorators) in this file that have
 * an @ExportDecoratedItems annotation must be defined as a regular function,
 * not an arrow function.
 */


function queryAssignedNodes(slotOrOptions, flatten, selector) {
    // Normalize the overloaded arguments.
    let slot = slotOrOptions;
    let assignedNodesOptions;
    if (typeof slotOrOptions === 'object') {
        slot = slotOrOptions.slot;
        assignedNodesOptions = slotOrOptions;
    }
    else {
        assignedNodesOptions = { flatten };
    }
    // For backwards compatibility, queryAssignedNodes with a selector behaves
    // exactly like queryAssignedElements with a selector.
    if (selector) {
        return queryAssignedElements({
            slot: slot,
            flatten,
            selector,
        });
    }
    return decorateProperty({
        descriptor: (_name) => ({
            get() {
                var _a, _b;
                const slotSelector = `slot${slot ? `[name=${slot}]` : ':not([name])'}`;
                const slotEl = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(slotSelector);
                return (_b = slotEl === null || slotEl === void 0 ? void 0 : slotEl.assignedNodes(assignedNodesOptions)) !== null && _b !== void 0 ? _b : [];
            },
            enumerable: true,
            configurable: true,
        }),
    });
}
//# sourceMappingURL=query-assigned-nodes.js.map
;// CONCATENATED MODULE: ./node_modules/lit/decorators.js

//# sourceMappingURL=decorators.js.map

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/ErrorMessage.js

const ErrorMessage = ({ title, children }) => lit_html.html `
  <div class="error-background">
    <div class="error-container">
      <span class="error-title"
        ><span class="error-badge">Error</span>${title}</span
      >
      <span class="error-description">${children}</span>
    </div>
  </div>
`;
const ErrorMessage_styles = css `
  .error-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;

    background: var(--error-bg);
    color: var(--error-fg);
  }

  .error-container {
    max-width: 800px;
    margin: auto;
    padding: 1em;
  }

  .error-badge {
    display: inline-block;
    font-size: 0.8em;
    padding: 0.2em 0.5em;
    margin-inline-end: 0.5em;

    background: var(--error-color);
    border-radius: 2px;
    color: var(--error-bg);
    text-transform: uppercase;
  }

  .error-title {
    display: block;
    font-size: 1.2em;

    font-weight: bold;
    text-transform: capitalize;
  }

  .error-description {
    display: block;
    margin-block-start: 1em;
  }
`;

;// CONCATENATED MODULE: ./node_modules/lit-html/development/directive.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const PartType = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6,
};
/**
 * Creates a user-facing directive function from a Directive class. This
 * function has the same parameters as the directive's render() method.
 */
const directive = (c) => (...values) => ({
    // This property needs to remain unminified.
    ['_$litDirective$']: c,
    values,
});
/**
 * Base class for creating custom directives. Users should extend this class,
 * implement `render` and/or `update`, and then pass their subclass to
 * `directive`.
 */
class Directive {
    constructor(_partInfo) { }
    // See comment in Disconnectable interface for why this is a getter
    get _$isConnected() {
        return this._$parent._$isConnected;
    }
    /** @internal */
    _$initialize(part, parent, attributeIndex) {
        this.__part = part;
        this._$parent = parent;
        this.__attributeIndex = attributeIndex;
    }
    /** @internal */
    _$resolve(part, props) {
        return this.update(part, props);
    }
    update(_part, props) {
        return this.render(...props);
    }
}
//# sourceMappingURL=directive.js.map
;// CONCATENATED MODULE: ./node_modules/lit-html/development/directives/style-map.js
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */


class StyleMapDirective extends Directive {
    constructor(partInfo) {
        var _a;
        super(partInfo);
        if (partInfo.type !== PartType.ATTRIBUTE ||
            partInfo.name !== 'style' ||
            ((_a = partInfo.strings) === null || _a === void 0 ? void 0 : _a.length) > 2) {
            throw new Error('The `styleMap` directive must be used in the `style` attribute ' +
                'and must be the only part in the attribute.');
        }
    }
    render(styleInfo) {
        return Object.keys(styleInfo).reduce((style, prop) => {
            const value = styleInfo[prop];
            if (value == null) {
                return style;
            }
            // Convert property names from camel-case to dash-case, i.e.:
            //  `backgroundColor` -> `background-color`
            // Vendor-prefixed names need an extra `-` appended to front:
            //  `webkitAppearance` -> `-webkit-appearance`
            // Exception is any property name containing a dash, including
            // custom properties; we assume these are already dash-cased i.e.:
            //  `--my-button-color` --> `--my-button-color`
            prop = prop
                .replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, '-$&')
                .toLowerCase();
            return style + `${prop}:${value};`;
        }, '');
    }
    update(part, [styleInfo]) {
        const { style } = part.element;
        if (this._previousStyleProperties === undefined) {
            this._previousStyleProperties = new Set();
            for (const name in styleInfo) {
                this._previousStyleProperties.add(name);
            }
            return this.render(styleInfo);
        }
        // Remove old properties that no longer exist in styleInfo
        // We use forEach() instead of for-of so that re don't require down-level
        // iteration.
        this._previousStyleProperties.forEach((name) => {
            // If the name isn't in styleInfo or it's null/undefined
            if (styleInfo[name] == null) {
                this._previousStyleProperties.delete(name);
                if (name.includes('-')) {
                    style.removeProperty(name);
                }
                else {
                    // Note reset using empty string (vs null) as IE11 does not always
                    // reset via null (https://developer.mozilla.org/en-US/docs/Web/API/ElementCSSInlineStyle/style#setting_styles)
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    style[name] = '';
                }
            }
        });
        // Add or update properties
        for (const name in styleInfo) {
            const value = styleInfo[name];
            if (value != null) {
                this._previousStyleProperties.add(name);
                if (name.includes('-')) {
                    style.setProperty(name, value);
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    style[name] = value;
                }
            }
        }
        return lit_html.noChange;
    }
}
/**
 * A directive that applies CSS properties to an element.
 *
 * `styleMap` can only be used in the `style` attribute and must be the only
 * expression in the attribute. It takes the property names in the
 * {@link StyleInfo styleInfo} object and adds the property values as CSS
 * properties. Property names with dashes (`-`) are assumed to be valid CSS
 * property names and set on the element's style object using `setProperty()`.
 * Names without dashes are assumed to be camelCased JavaScript property names
 * and set on the element's style object using property assignment, allowing the
 * style object to translate JavaScript-style names to CSS property names.
 *
 * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':
 * '0'})` sets the `background-color`, `border-top` and `--size` properties.
 *
 * @param styleInfo
 * @see {@link https://lit.dev/docs/templates/directives/#stylemap styleMap code samples on Lit.dev}
 */
const styleMap = directive(StyleMapDirective);
//# sourceMappingURL=style-map.js.map
;// CONCATENATED MODULE: ./node_modules/lit/directives/style-map.js

//# sourceMappingURL=style-map.js.map

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/utils.js
function absRect(rect) {
    return {
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height,
        left: rect.x,
    };
}
function getDistanceGuides(selected, compared) {
    const a = absRect(selected);
    const b = absRect(compared);
    const isYIntersecting = !(a.top > b.bottom || a.bottom < b.top);
    const isXIntersecting = !(a.left > b.right || a.right < b.left);
    // Rects are intersecting.
    if (isXIntersecting && isYIntersecting) {
        // Center of intersecting region.
        const intersectCenter = {
            x: (Math.max(a.left, b.left) + Math.min(a.right, b.right)) / 2,
            y: (Math.max(a.top, b.top) + Math.min(a.bottom, b.bottom)) / 2,
        };
        return [
            {
                points: [
                    { x: a.left, y: intersectCenter.y },
                    { x: b.left, y: intersectCenter.y },
                ],
            },
            {
                points: [
                    {
                        x: a.right,
                        y: intersectCenter.y,
                    },
                    { x: b.right, y: intersectCenter.y },
                ],
            },
            {
                points: [
                    { y: a.top, x: intersectCenter.x },
                    { y: b.top, x: intersectCenter.x },
                ],
            },
            {
                points: [
                    {
                        y: a.bottom,
                        x: intersectCenter.x,
                    },
                    { y: b.bottom, x: intersectCenter.x },
                ],
            },
        ];
    }
    const isALeft = a.left > b.right;
    const isABelow = a.top > b.bottom;
    const selectedCenter = {
        x: selected.x + selected.width / 2,
        y: selected.y + selected.height / 2,
    };
    const guides = [
        !isXIntersecting
            ? {
                points: [
                    { x: isALeft ? a.left : a.right, y: selectedCenter.y },
                    { x: isALeft ? b.right : b.left, y: selectedCenter.y },
                ],
                bisector: !isYIntersecting
                    ? [
                        { x: isALeft ? b.right : b.left, y: selectedCenter.y },
                        {
                            x: isALeft ? b.right : b.left,
                            y: isABelow ? b.bottom : b.top,
                        },
                    ]
                    : void 0,
            }
            : null,
        !isYIntersecting
            ? {
                points: [
                    { y: isABelow ? a.top : a.bottom, x: selectedCenter.x },
                    { y: isABelow ? b.bottom : b.top, x: selectedCenter.x },
                ],
                bisector: !isXIntersecting
                    ? [
                        { y: isABelow ? b.bottom : b.top, x: selectedCenter.x },
                        {
                            y: isABelow ? b.bottom : b.top,
                            x: isALeft ? b.right : b.left,
                        },
                    ]
                    : void 0,
            }
            : null,
    ];
    return guides.filter((x) => !!x);
}
/**
 * x.xxxxx... -> x.xx
 */
function round(n) {
    return Math.round(n * 100) / 100;
}
function extendStyles(left, right) {
    return [...stylesToArray(left), ...stylesToArray(right)];
}
function stylesToArray(styles) {
    if (!styles) {
        return [];
    }
    if (styles instanceof Array) {
        return styles;
    }
    return [styles];
}

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/NodeSelectableMixin.js
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

const NodeSelectableMixin = (superClass) => {
    class NodeSelectable extends superClass {
        constructor(...args) {
            super(...args);
            this.selectedNode = null;
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has("selectedNode")) {
                this.dispatchEvent(new CustomEvent("nodeselect", {
                    detail: {
                        selectedNode: this.selectedNode,
                    },
                }));
            }
        }
    }
    __decorate([
        property({
            attribute: false,
        })
    ], NodeSelectable.prototype, "selectedNode", void 0);
    return NodeSelectable;
};

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/TouchGestureMixin.js
function shouldSkipEvent(ev) {
    return ev.touches.length === 0 || ev.touches.length > 2;
}
function getDistance(a, b) {
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
const TouchGestureMixin = (superClass) => class CTouchGesture extends superClass {
    constructor(...args) {
        super(...args);
        this.previousTouches = null;
        this.addEventListener("touchstart", (ev) => {
            if (shouldSkipEvent(ev)) {
                return;
            }
            ev.preventDefault();
            this.previousTouches = ev.touches;
        });
        this.addEventListener("touchend", (ev) => {
            if (shouldSkipEvent(ev)) {
                return;
            }
            ev.preventDefault();
            this.previousTouches = null;
        });
        this.addEventListener("touchcancel", (ev) => {
            if (shouldSkipEvent(ev)) {
                return;
            }
            ev.preventDefault();
            this.previousTouches = null;
        });
        this.addEventListener("touchmove", (ev) => {
            if (shouldSkipEvent(ev)) {
                return;
            }
            const previousTouches = Array.from(this.previousTouches || []);
            const currentTouches = Array.from(ev.touches);
            this.previousTouches = ev.touches;
            // When one or more than one of touch input sources differs, skip processing.
            if (currentTouches.length !== previousTouches.length ||
                !currentTouches.every((t) => previousTouches.some((pt) => pt.identifier === t.identifier))) {
                return;
            }
            // Pan
            if (currentTouches.length === 1) {
                this.onTouchPan({
                    x: currentTouches[0].pageX - previousTouches[0].pageX,
                    y: currentTouches[0].pageY - previousTouches[0].pageY,
                });
                return;
            }
            // Pinch
            this.onTouchPinch(getDistance({
                x: currentTouches[0].pageX,
                y: currentTouches[0].pageY,
            }, {
                x: previousTouches[0].pageX,
                y: previousTouches[0].pageY,
            }));
            return;
        });
    }
    get isTouching() {
        return !!(this.previousTouches && this.previousTouches.length > 0);
    }
    onTouchPan(delta) { }
    onTouchPinch(delta) { }
};

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/PositionedMixin.js
var PositionedMixin_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};


const PositionedMixin = (superClass) => {
    var _isDragModeOn, _movePanel, _keyDown, _keyUp, _listenToKeyboardEvents;
    class Positioned extends TouchGestureMixin(superClass) {
        constructor(...args) {
            super(...args);
            this.panX = 0;
            this.panY = 0;
            this.scale = 1;
            this.zoomSpeed = 500;
            this.panSpeed = 500;
            _isDragModeOn.set(this, false);
            _movePanel.set(this, (shiftX, shiftY) => {
                this.panX += shiftX / this.scale / window.devicePixelRatio;
                this.panY += shiftY / this.scale / window.devicePixelRatio;
            });
            // Enable drag mode when holding the spacebar
            _keyDown.set(this, (event) => {
                if (event.code === "Space" && !__classPrivateFieldGet(this, _isDragModeOn)) {
                    __classPrivateFieldSet(this, _isDragModeOn, true);
                    document.body.style.cursor = "grab";
                }
            });
            // Disable drag mode when space lets the spacebar go
            _keyUp.set(this, (event) => {
                if (event.code === "Space" && __classPrivateFieldGet(this, _isDragModeOn)) {
                    __classPrivateFieldSet(this, _isDragModeOn, false);
                    document.body.style.cursor = "auto";
                }
            });
            _listenToKeyboardEvents.set(this, () => {
                document.addEventListener("keyup", __classPrivateFieldGet(this, _keyUp));
                document.addEventListener("keydown", __classPrivateFieldGet(this, _keyDown));
            });
            this.addEventListener("wheel", (ev) => {
                if (!this.isMovable)
                    return;
                ev.preventDefault();
                if (ev.ctrlKey) {
                    // Performs zoom when ctrl key is pressed.
                    let { deltaY } = ev;
                    if (ev.deltaMode === 1) {
                        // Firefox quirk
                        deltaY *= 15;
                    }
                    const prevScale = this.scale;
                    this.scale *= 1 - deltaY / ((1000 - this.zoomSpeed) * 0.5);
                    // Performs pan to archive "zoom at the point" behavior (I don't know how to call it).
                    const offsetX = ev.offsetX - this.offsetWidth / 2;
                    const offsetY = ev.offsetY - this.offsetHeight / 2;
                    this.panX += offsetX / this.scale - offsetX / prevScale;
                    this.panY += offsetY / this.scale - offsetY / prevScale;
                }
                else {
                    // Performs pan otherwise (to be close to native behavior)
                    // Adjusting panSpeed in order to make panSpeed=500 to match to the Figma's one.
                    const speed = this.panSpeed * 0.002;
                    this.panX -= (ev.deltaX * speed) / this.scale;
                    this.panY -= (ev.deltaY * speed) / this.scale;
                }
            }, 
            // This component prevents every native wheel behavior on it.
            { passive: false });
            // Base scale for Safari's GestureEvents
            let gestureStartScale = 1;
            this.addEventListener("gesturestart", (ev) => {
                ev.preventDefault();
                gestureStartScale = this.scale;
            });
            this.addEventListener("gesturechange", (_ev) => {
                const ev = _ev;
                ev.preventDefault();
                // We can't perform zoom-at-the-point due to lack of offsetX/Y in GestureEvent
                this.scale = gestureStartScale * ev.scale;
            });
            this.addEventListener("pointermove", (ev) => {
                // Performs pan only when middle buttons is pressed.
                //
                // 4 ... Auxiliary button (usually the mouse wheel button or middle button)
                // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
                if (!(ev.buttons & 4))
                    return;
                ev.preventDefault();
                // Moving amount of middle button+pointer move panning should matches to the actual
                // pointer travel distance. Since translate goes after scaling, we need to scale
                // delta too.
                __classPrivateFieldGet(this, _movePanel).call(this, ev.movementX, ev.movementY);
            });
            // Listen to keyboard events to enable dragging when Space is pressed, just like in Figma
            __classPrivateFieldGet(this, _listenToKeyboardEvents).call(this);
            /** @private */
            this.onmousedown = () => {
                if (__classPrivateFieldGet(this, _isDragModeOn)) {
                    document.body.style.cursor = "grabbing";
                    this.onmousemove = ({ movementX, movementY }) => {
                        __classPrivateFieldGet(this, _movePanel).call(this, movementX, movementY);
                    };
                    // cleanup unnecessary listeners when user stops dragging
                    this.onmouseup = () => {
                        document.body.style.cursor = "grab";
                        this.onmousemove = null;
                        this.onmouseup = null;
                    };
                }
            };
        }
        get isMovable() {
            return true;
        }
        get canvasTransform() {
            return [
                `scale(${this.scale})`,
                `translate(${this.panX}px, ${this.panY}px)`,
            ];
        }
        disconnectedCallback() {
            document.removeEventListener("keyup", __classPrivateFieldGet(this, _keyUp));
            document.removeEventListener("keydown", __classPrivateFieldGet(this, _keyDown));
            super.disconnectedCallback();
        }
        // Dispatch events when the position-related value changes.
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has("scale")) {
                this.dispatchEvent(new CustomEvent("scalechange", {
                    detail: {
                        scale: this.scale,
                    },
                }));
            }
            if (changedProperties.has("panX") || changedProperties.has("panY")) {
                this.dispatchEvent(new CustomEvent("positionchange", {
                    detail: {
                        x: this.panX,
                        y: this.panY,
                    },
                }));
            }
        }
        onTouchPan(delta) {
            this.panX += delta.x / this.scale;
            this.panY += delta.y / this.scale;
        }
        onTouchPinch(delta) {
            // TODO: Remove this no-brainer magic number
            this.scale *= 1 - delta / 1000;
        }
    }
    _isDragModeOn = new WeakMap(), _movePanel = new WeakMap(), _keyDown = new WeakMap(), _keyUp = new WeakMap(), _listenToKeyboardEvents = new WeakMap();
    PositionedMixin_decorate([
        property({
            attribute: false,
        })
    ], Positioned.prototype, "panX", void 0);
    PositionedMixin_decorate([
        property({
            attribute: false,
        })
    ], Positioned.prototype, "panY", void 0);
    PositionedMixin_decorate([
        property({
            attribute: false,
        })
    ], Positioned.prototype, "scale", void 0);
    PositionedMixin_decorate([
        property({
            type: Number,
            attribute: "zoom-speed",
        })
    ], Positioned.prototype, "zoomSpeed", void 0);
    PositionedMixin_decorate([
        property({
            type: Number,
            attribute: "pan-speed",
        })
    ], Positioned.prototype, "panSpeed", void 0);
    return Positioned;
};

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/DistanceGuide.js



const Line = ({ guide, reverseScale }) => {
    const xLength = Math.abs(guide.points[0].x - guide.points[1].x);
    const yLength = Math.abs(guide.points[0].y - guide.points[1].y);
    if (xLength === 0 && yLength === 0) {
        return null;
    }
    return lit_html.svg `
    <line
      class="distance-line"
      x1=${guide.points[0].x}
      y1=${guide.points[0].y}
      x2=${guide.points[1].x}
      y2=${guide.points[1].y}
    />

    ${guide.bisector &&
        lit_html.svg `
        <line
          class="distance-line"
          x1=${guide.bisector[0].x}
          y1=${guide.bisector[0].y}
          x2=${guide.bisector[1].x}
          y2=${guide.bisector[1].y}
          style=${styleMap({
            strokeDasharray: `${4 * reverseScale}`,
        })}
          shape-rendering="geometricPrecision"
          fill="none"
        />
      `}
  `;
};
const Tooltip = ({ guide, reverseScale, fontSize }) => {
    const xLength = Math.abs(guide.points[0].x - guide.points[1].x);
    const yLength = Math.abs(guide.points[0].y - guide.points[1].y);
    if (xLength === 0 && yLength === 0) {
        return null;
    }
    const text = round(Math.max(xLength, yLength)).toString(10);
    // Decreases font width because every text is a number (narrow).
    // We can measure the correct width with getComputedTextLength method on
    // <text> element, but it needs access to DOM or creating an element each
    // render cycle, both have performance costs.
    const width = text.length * fontSize * 0.5;
    const startMargin = fontSize * 0.25;
    const vPadding = fontSize * 0.25;
    const hPadding = fontSize * 0.5;
    const x = xLength > yLength
        ? (guide.points[0].x + guide.points[1].x) / 2 - width / 2
        : guide.points[0].x;
    const y = xLength > yLength
        ? guide.points[0].y
        : (guide.points[0].y + guide.points[1].y) / 2 - fontSize / 2;
    const transform = [
        `scale(${reverseScale})`,
        xLength > yLength
            ? `translate(0, ${startMargin + vPadding})`
            : `translate(${startMargin + hPadding}, 0)`,
    ].join(" ");
    const cx = x + width / 2;
    const cy = y + fontSize / 2;
    const transformOrigin = xLength > yLength ? `${cx} ${y}` : `${x} ${cy}`;
    return lit_html.svg `
    <g class="distance-tooltip">
      <rect
        x=${x - hPadding}
        y=${y - vPadding}
        rx="2"
        width=${width + hPadding * 2}
        height=${fontSize + vPadding * 2}
        transform=${transform}
        transform-origin=${transformOrigin}
        stroke="none"
      />

      <text
        x=${cx}
        y=${y + fontSize - vPadding / 2}
        text-anchor="middle"
        transform=${transform}
        transform-origin=${transformOrigin}
        stroke="none"
        fill="white"
        style="font-size: ${fontSize}px"
      >
        ${text}
      </text>
    </g>
  `;
};
const guidesCache = new Map();
const Guides = ({ node, distanceTo, reverseScale, fontSize, }) => {
    const combinedId = node.id + "\n" + distanceTo.id;
    let guides = guidesCache.get(combinedId);
    if (!guides) {
        guides = getDistanceGuides(node.absoluteBoundingBox, distanceTo.absoluteBoundingBox);
        guidesCache.set(combinedId, guides);
    }
    return [
        ...guides.map((guide) => Line({ guide, reverseScale })),
        ...guides.map((guide) => Tooltip({ guide, reverseScale, fontSize })),
    ];
};
const DistanceGuide_styles = css `
  .distance-line {
    shape-rendering: geometricPrecision;
    fill: none;
    opacity: 0;
  }

  .distance-tooltip {
    opacity: 0;
  }

  .guide:hover ~ .distance-line,
  .guide:hover ~ .distance-tooltip {
    opacity: 1;
  }
`;

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/Icons.js

const CloseIcon = ({ onClick = () => { } }) => lit_html.svg `
  <svg @click=${onClick} title="close icon" width="14" height="14" viewBox="0 0 20 20" fill="none">
    <path d="M1 19L19 1M19 19L1 1" stroke="#B3B3B3" stroke-width="2"/>
  </svg>
`;
const CopyIcon = ({ onClick = () => { } }) => lit_html.svg `
  <svg @click=${onClick} title="copy icon" width="14" height="14" viewBox="0 0 30 30" fill="none">
  <path d="M21 25.5C21 24.9477 20.5523 24.5 20 24.5C19.4477 24.5 19 24.9477 19 25.5H21ZM13 2H25V0H13V2ZM28 5V21H30V5H28ZM25 24H13V26H25V24ZM10 21V5H8V21H10ZM13 24C11.3431 24 10 22.6569 10 21H8C8 23.7614 10.2386 26 13 26V24ZM28 21C28 22.6569 26.6569 24 25 24V26C27.7614 26 30 23.7614 30 21H28ZM25 2C26.6569 2 28 3.34315 28 5H30C30 2.23858 27.7614 0 25 0V2ZM13 0C10.2386 0 8 2.23858 8 5H10C10 3.34315 11.3431 2 13 2V0ZM16.5 28H5V30H16.5V28ZM2 25V10H0V25H2ZM5 28C3.34315 28 2 26.6569 2 25H0C0 27.7614 2.23858 30 5 30V28ZM5 7H8V5H5V7ZM2 10C2 8.34315 3.34315 7 5 7V5C2.23858 5 0 7.23858 0 10H2ZM16.5 30C18.9853 30 21 27.9853 21 25.5H19C19 26.8807 17.8807 28 16.5 28V30Z" fill="#B3B3B3"/>
</svg>
`;
const HorizontalPaddingIcon = () => lit_html.svg `
  <svg title="horizontal padding" width="14" height="14" viewBox="0 0 29 28" fill="none">
    <rect x="7" y="8" width="14" height="14" stroke="#B3B3B3" stroke-width="2"/>
    <path d="M27 1V28" stroke="#B3B3B3" stroke-width="2"/>
    <path d="M1 0V28" stroke="#B3B3B3" stroke-width="2"/>
  </svg>
`;
const VerticalPaddingIcon = () => lit_html.svg `
  <svg title="vertical padding" width="14" height="14" viewBox="0 0 29 28" fill="none" xmlns="http://www.w3.org/2000/svg">
    <rect x="8" y="21" width="14" height="14" transform="rotate(-90 8 21)" stroke="#B3B3B3" stroke-width="2"/>
    <path d="M1 1L28 0.999999" stroke="#B3B3B3" stroke-width="2"/>
    <path d="M0 27L28 27" stroke="#B3B3B3" stroke-width="2"/>
  </svg>
`;
const FigmaIcon = () => lit_html.svg `
  <svg title="figma logo" width="11" height="16" viewBox="0 0 12 17" xmlns="http://www.w3.org/2000/svg">
    <path
      d="M5.5 1.5h-2c-1.105 0-2 .895-2 2 0 1.105.895 2 2 2h2v-4zm-5 2c0 1.043.533 1.963 1.341 2.5C1.033 6.537.5 7.457.5 8.5c0 1.043.533 1.963 1.341 2.5C1.033 11.537.5 12.457.5 13.5c0 1.657 1.343 3 3 3 1.657 0 3-1.343 3-3V10.736c.53.475 1.232.764 2 .764 1.657 0 3-1.343 3-3 0-1.043-.533-1.963-1.341-2.5.808-.537 1.341-1.457 1.341-2.5 0-1.657-1.343-3-3-3h-5c-1.657 0-3 1.343-3 3zm1 5c0-1.105.895-2 2-2h2v4h-2c-1.105 0-2-.895-2-2zm0 5c0-1.105.895-2 2-2h2v2c0 1.105-.895 2-2 2-1.105 0-2-.895-2-2zm7-3c-1.105 0-2-.895-2-2 0-1.105.895-2 2-2 1.105 0 2 .895 2 2 0 1.105-.895 2-2 2zm0-5h-2v-4h2c1.105 0 2 .895 2 2 0 1.105-.895 2-2 2z"
      fill-rule="evenodd"
      fill-opacity="1"
      fill="#000"
      stroke="none"
    ></path>
  </svg>
`;

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/InspectorView/utils.js
const extractColorStyle = (color) => {
    if (color.a === 0) {
        return "transparent";
    }
    else if (color.a < 1) {
        return `rgba(${rgbToIntArray(color).join(", ")}, ${color.a.toFixed(2)})`;
    }
    else {
        return rgbToHex(color);
    }
};
const extractGradientColorStyle = (color) => {
    return new Gradient(color).cssColor;
};
class Gradient {
    constructor(data) {
        this.gradientHandles = {
            start: data.gradientHandlePositions[0],
            end: data.gradientHandlePositions[1],
        };
        this.colors = data.gradientStops;
        this.colorObjects = this.createColorObjects(this.colors);
        this.angle = this.calculateAngle(this.gradientHandles.start, this.gradientHandles.end);
    }
    get cssGradientArray() {
        return this.colorObjects.map((color, index) => {
            const position = this.floatToPercent(this.colors[index].position);
            return color + " " + position;
        });
    }
    get cssColor() {
        const cssGradientArray = this.cssGradientArray;
        cssGradientArray.unshift(this.angle + "deg");
        return `linear-gradient(${cssGradientArray.join(", ")})`;
    }
    createColorObjects(colors) {
        return colors.map(({ color }) => extractColorStyle(color));
    }
    floatToPercent(value) {
        return (value *= 100).toFixed(0) + "%";
    }
    calculateAngle(startHandle, endHandle) {
        const radians = Math.atan(this.calculateGradient(startHandle, endHandle));
        return parseInt(this.radToDeg(radians).toFixed(1));
    }
    calculateGradient(startHandle, endHandle) {
        return ((endHandle.y - startHandle.y) / (endHandle.x - startHandle.x)) * -1;
    }
    radToDeg(radian) {
        return (180 * radian) / Math.PI;
    }
}
class NodeStyles {
    constructor(node) {
        var _a, _b, _c;
        this.hasPadding = false;
        this.height = `${Math.trunc(node.absoluteBoundingBox.height)}px`;
        this.width = `${Math.trunc(node.absoluteBoundingBox.width)}px`;
        // paddings
        if (node.horizontalPadding || node.verticalPadding) {
            this.hasPadding = true;
            this.horizontalPadding = `${node.horizontalPadding}px`;
            this.verticalPadding = `${node.verticalPadding}px`;
        }
        // font styles
        if (node.style) {
            this.fontFamily = node.style.fontFamily;
            this.fontPostScriptName = (_a = node.style.fontPostScriptName) === null || _a === void 0 ? void 0 : _a.replace("-", " ");
            this.fontWeight = node.style.fontWeight;
            this.fontSize = `${Math.ceil(node.style.fontSize)}px`;
            this.lineHeight = `${Math.trunc(node.style.lineHeightPx)}px`;
        }
        // border radii
        if (node.rectangleCornerRadii) {
            this.borderRadius =
                node.rectangleCornerRadii.filter((radius) => radius === node.cornerRadius).length < 4
                    ? `${node.rectangleCornerRadii.join("px ")}px`
                    : `${node.cornerRadius}px`;
        }
        // colors, background, fill
        if (node.backgroundColor || node.backgroundColor) {
            const color = node.backgroundColor || ((_b = node.background) === null || _b === void 0 ? void 0 : _b[0].color);
            this.background = extractColorStyle(color);
        }
        const fillColor = (_c = node.fills) === null || _c === void 0 ? void 0 : _c[0];
        if (fillColor && fillColor.visible !== false) {
            if (node.type === "TEXT") {
                this.color = extractColorStyle(fillColor.color);
            }
            else if (fillColor.type.includes("GRADIENT")) {
                this.backgroundImage = extractGradientColorStyle(fillColor);
            }
            else if (fillColor.type === "SOLID") {
                this.background = extractColorStyle(fillColor.color);
            }
        }
        // borders
        if (node.strokes && node.strokes.length > 0) {
            this.borderColor = extractColorStyle(node.strokes[0].color);
            this.border = `${node.strokeWeight}px solid ${this.borderColor}`;
        }
        // box-shadow
        if (node.effects && node.effects.length > 0) {
            const { offset, radius, color } = node.effects[0];
            this.boxShadowColor = extractColorStyle(color);
            this.boxShadow = `${(offset === null || offset === void 0 ? void 0 : offset.x) || 0}px ${(offset === null || offset === void 0 ? void 0 : offset.y) || 0}px 0 ${radius} ${this.boxShadowColor}`;
        }
    }
    getStyles() {
        return [
            this.height && { property: "height", value: this.height },
            this.width && { property: "width", value: this.width },
            this.fontFamily && { property: "font-family", value: this.fontFamily },
            this.fontSize && { property: "font-size", value: this.fontSize },
            this.fontWeight && { property: "font-weight", value: this.fontWeight },
            this.lineHeight && { property: "line-height", value: this.lineHeight },
            this.borderRadius && {
                property: "border-radius",
                value: this.borderRadius,
            },
            this.backgroundImage && {
                property: "background-image",
                value: this.backgroundImage,
            },
            this.boxShadow && {
                property: "box-shadow",
                value: this.boxShadow,
                color: this.boxShadowColor,
            },
            this.border && {
                property: "border",
                value: this.border,
                color: this.borderColor,
            },
            this.background && {
                property: "background",
                value: this.background,
                color: this.background,
            },
            this.color && { property: "color", value: this.color, color: this.color },
        ].filter(Boolean);
    }
    getStyleSheet() {
        return this.getStyles().map(getStyleRule).join("\n");
    }
}
const rgbToIntArray = (color) => [
    Math.trunc(255 * color.r),
    Math.trunc(255 * color.g),
    Math.trunc(255 * color.b),
];
const rgbToHex = (color) => {
    const [r, g, b] = rgbToIntArray(color);
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
};
const getStyleRule = ({ property, value }) => `${property}: ${value};`;

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/InspectorView/InspectorView.js
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const copy = (text) => __awaiter(void 0, void 0, void 0, function* () {
    yield navigator.clipboard.writeText(text);
});
const View = ({ node, onClose }) => {
    if (!node) {
        return null;
    }
    const nodeStyles = new NodeStyles(node);
    // In order to disable canvas interactions (e.g. pan, click to
    // deselect), we need to cancel JavaScript event propagation
    // on the root element.
    const stopPropagation = (ev) => ev.stopPropagation();
    return lit_html.html `
    <div
      class="inspector-view"
      @click=${stopPropagation}
      @wheel=${stopPropagation}
      @keydown=${stopPropagation}
      @keyup=${stopPropagation}
      @pointermove=${stopPropagation}
    >
      <div class="inspector-section selectable-content">
        <div class="title-section">
          <h4>${node.name}</h4>
          ${CloseIcon({ onClick: onClose })}
        </div>
        <div class="properties-overview">
          <div class="title-section">
            <p class="inspector-property">
              <span>W: </span>${nodeStyles.width}
            </p>
            <p class="inspector-property" style="margin-left: 16px;">
              <span>H: </span>${nodeStyles.height}
            </p>
          </div>
          ${nodeStyles.fontPostScriptName
        ? lit_html.html `<p class="inspector-property">
                <span>Font:</span>
                ${nodeStyles.fontPostScriptName}
              </p>`
        : null}
        </div>
      </div>
      ${nodeStyles.hasPadding
        ? lit_html.html `<div class="inspector-section">
            <h4>Layout</h4>
            ${nodeStyles.horizontalPadding &&
            lit_html.html `<p class="inspector-property">
              ${HorizontalPaddingIcon()} ${nodeStyles.horizontalPadding}
            </p>`}
            ${nodeStyles.verticalPadding &&
            lit_html.html `<p class="inspector-property">
              ${VerticalPaddingIcon()} ${nodeStyles.verticalPadding}
            </p>`}
          </div>`
        : null}
      ${node.characters
        ? lit_html.html `<div class="inspector-section">
            <div class="title-section">
              <h4>Content</h4>
              ${CopyIcon({ onClick: () => copy(node.characters) })}
            </div>
            <p class="node-content code-section selectable-content">
              ${node.characters}
            </p>
          </div>`
        : null}
      ${StylesSection(nodeStyles)}
    </div>
  `;
};
const StylesSection = (nodeStyles) => {
    const onClick = () => copy(nodeStyles.getStyleSheet());
    const styles = nodeStyles.getStyles();
    return lit_html.html `<div class="inspector-section">
    <div class="title-section style-section">
      <h4>CSS</h4>
      ${CopyIcon({ onClick })}
    </div>
    <div class="code-section selectable-content">
      ${styles.map(CSSProperty)}
    </div>
  </div>`;
};
const CSSProperty = (cssProperty) => {
    const { property, value, color } = cssProperty;
    let coloredSquare = null;
    switch (property) {
        case "background":
        case "fill":
        case "border":
        case "box-shadow":
        case "color":
            coloredSquare = lit_html.html `<span
        class="color-preview"
        style="background-color: ${color}"
      ></span>`;
            break;
        case "background-image":
            coloredSquare = lit_html.html `<span
        class="color-preview"
        style="background-image: ${value}"
      ></span>`;
            break;
    }
    return lit_html.html `<div class="css-property" @click=${() => copy(getStyleRule(cssProperty))}>
    <span>${property}:</span>${coloredSquare}<span class="css-value">${value}</span>;</span>
  </div>`;
};
const InspectorView_styles = css `
  .inspector-view {
    height: 100%;
    width: 300px;
    position: absolute;
    right: 0;
    background: white;
    border-left: 1px solid #ccc;
    overflow-y: auto;
    z-index: calc(var(--z-index) + 2);
  }

  .inspector-view h4 {
    font-size: 16px;
    margin: 0;
  }

  .style-section {
    margin-bottom: 12px;
  }

  .title-section {
    display: flex;
    align-items: center;
  }

  .code-section {
    padding: 8px;
    background: #f3f3f3;
    font-family: monospace;
  }

  .title-section svg {
    cursor: pointer;
    margin-left: auto;
  }

  .inspector-section {
    padding: 16px;
    border-bottom: 1px solid #eee;
  }

  .properties-overview {
    font-family: monospace;
    color: #518785;
  }

  .properties-overview p span {
    color: #121212;
  }

  .inspector-property {
    display: flex;
    align-items: center;
    margin-bottom: 0;
  }

  .inspector-property span {
    color: #b3b3b3;
    margin-right: 4px;
  }

  .inspector-property svg {
    margin-right: 8px;
  }

  .css-property {
    margin: 8px;
    transition: background-color ease-in-out 100ms;
  }

  .css-property:hover {
    cursor: pointer;
    background-color: #e8e8e8;
  }

  .css-value {
    color: #518785;
    margin-left: 4px;
  }

  .color-preview {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 1px solid #ccc;
    margin-left: 4px;
    vertical-align: middle;
  }

  .selectable-content {
    cursor: text;
    user-select: text;
  }
`;

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/Node.js



const Outline = ({ node, selected = false, computedThickness, onClick, }) => {
    const { x, y, width, height } = node.absoluteBoundingBox;
    const radius = "cornerRadius" in node && node.cornerRadius
        ? {
            topLeft: node.cornerRadius,
            topRight: node.cornerRadius,
            bottomRight: node.cornerRadius,
            bottomLeft: node.cornerRadius,
        }
        : "rectangleCornerRadii" in node && node.rectangleCornerRadii
            ? {
                topLeft: node.rectangleCornerRadii[0],
                topRight: node.rectangleCornerRadii[1],
                bottomRight: node.rectangleCornerRadii[2],
                bottomLeft: node.rectangleCornerRadii[3],
            }
            : {
                topLeft: 0,
                topRight: 0,
                bottomRight: 0,
                bottomLeft: 0,
            };
    // Since SVG can't control where to draw borders (I mean you can't draw inset borders), we need to
    // shift each drawing points by the half of the border width.
    const shift = computedThickness / 2;
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
    // [M] ... Move to
    // [L] ... Line to
    // [A] ... Arc to
    // [Z] ... Close path
    const moveTo = (x, y) => `M${x},${y}`;
    const lineTo = (x, y) => `L${x},${y}`;
    const arcTo = (r, x, y) => `A${r},${r} 0 0 1 ${x},${y}`;
    const boxPath = [
        moveTo(radius.topLeft + shift, shift),
        lineTo(width - radius.topRight, shift),
        arcTo(radius.topRight - shift, width - shift, radius.topRight),
        lineTo(width - shift, height - radius.bottomRight),
        arcTo(radius.bottomRight - shift, width - radius.bottomRight, height - shift),
        lineTo(radius.bottomLeft, height - shift),
        arcTo(radius.bottomLeft - shift, shift, height - radius.bottomLeft),
        lineTo(shift, radius.topLeft),
        arcTo(radius.topLeft - shift, radius.topLeft, shift),
        "Z",
    ].join(" ");
    return lit_html.svg `
    <path
      class="guide"
      d=${boxPath}
      shape-rendering="geometricPrecision"
      fill="none"
      transform="translate(${x}, ${y})"
      ?data-selected=${selected}
      @click=${onClick}
    />
  `;
};
const Node_Tooltip = ({ nodeSize: { x, y, width, height }, offsetX, offsetY, reverseScale, }) => {
    const tooltipStyle = {
        top: `${offsetY + y + height}px`,
        left: `${offsetX + x + width / 2}px`,
        transform: `translateX(-50%) scale(${reverseScale}) translateY(0.25em)`,
    };
    return lit_html.html `
    <div class="tooltip" style="${styleMap(tooltipStyle)}">
      ${round(width)} x ${round(height)}
    </div>
  `;
};
const Node_styles = css `
  .guide {
    /*
     * SVGs cannot be pixel perfect, especially floating values.
     * Since many platform renders them visually incorrectly (probably they
     * are following the spec), it's safe to set overflow to visible.
     * Cropped borders are hard to visible and ugly.
     */
    overflow: visible;

    pointer-events: all;

    opacity: 0;
  }
  .guide:hover {
    opacity: 1;
  }
  .guide[data-selected] {
    opacity: 1;
    stroke: var(--guide-selected-color);
  }

  .tooltip {
    position: absolute;
    padding: 0.25em 0.5em;
    font-size: var(--guide-tooltip-font-size);

    color: var(--guide-selected-tooltip-fg);
    background-color: var(--guide-selected-tooltip-bg);
    border-radius: 2px;
    pointer-events: none;
    z-index: calc(var(--z-index) + 1);

    transform-origin: top center;
  }
`;

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/Footer/utils.js
const SECOND = 1000;
const MINUTE = 60 * SECOND;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
const WEEK = 7 * DAY;
const MONTH = 30 * DAY;
const YEAR = 365 * DAY;
const intervals = [
    { gte: YEAR, divisor: YEAR, unit: "year" },
    { gte: MONTH, divisor: MONTH, unit: "month" },
    { gte: WEEK, divisor: WEEK, unit: "week" },
    { gte: DAY, divisor: DAY, unit: "day" },
    { gte: HOUR, divisor: HOUR, unit: "hour" },
    { gte: MINUTE, divisor: MINUTE, unit: "minute" },
    { gte: 30 * SECOND, divisor: SECOND, unit: "seconds" },
    { gte: 0, divisor: 1, text: "just now" },
];
const getTime = (targetDate) => {
    const date = typeof targetDate === "object"
        ? targetDate
        : new Date(targetDate);
    return date.getTime();
};
/**
 * Receives two dates to compare and returns "time ago" based on them
 * example: 4 weeks ago
 *
 * Heavily inspired by https://stackoverflow.com/a/67338038/938822
 */
const fromNow = (date, nowDate = Date.now(), rft = new Intl.RelativeTimeFormat(undefined, { numeric: "auto" })) => {
    const now = getTime(nowDate);
    const diff = now - getTime(date);
    const diffAbs = Math.abs(diff);
    for (const interval of intervals) {
        if (diffAbs >= interval.gte) {
            const x = Math.round(Math.abs(diff) / interval.divisor);
            const isInFuture = diff < 0;
            const intervalUnit = interval.unit;
            return intervalUnit
                ? rft.format(isInFuture ? x : -x, intervalUnit)
                : interval.text;
        }
    }
};

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/Footer/Footer.js



const Footer_styles = css `
  .figma-footer {
    flex: 0;
    z-index: calc(var(--z-index) + 1);
    border-top: 1px solid #ccc;
    min-height: 48px;
    padding: 0 16px;
    text-decoration: none;
    display: flex;
    flex-direction: row;
    justify-content: start;
    align-items: center;
    background-color: #fff;
    overflow-x: auto;
    cursor: pointer;
    font-size: 12px;
    color: rgba(0, 0, 0, 0.8);
  }

  .figma-footer--icon {
    margin-right: 12px;
  }

  .figma-footer--title {
    font-weight: 600;
    margin-right: 4px;

    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .figma-footer--timestamp {
    white-space: nowrap;
    overflow: hidden;
  }
`;
const Footer = (metadata) => {
    // Do not render in case there is no metadata or a link is not passed
    if (!metadata ||
        !metadata.link ||
        metadata.link === undefined ||
        metadata.link === "undefined") {
        return null;
    }
    const { link, timestamp, fileName } = metadata;
    return lit_html.html `<a
    class="figma-footer"
    target="_blank"
    rel="noopener"
    title="Open in Figma"
    href="${link}"
  >
    <span class="figma-footer--icon"> ${FigmaIcon()} </span>
    <span class="figma-footer--title"> ${fileName} </span>
    <span
      title="Last time edited: ${new Date(timestamp).toUTCString()}"
      class="figma-footer--timestamp"
    >
      Edited ${fromNow(timestamp)}
    </span>
  </a>`;
};

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/ViewerMixin.js
var ViewerMixin_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ViewerMixin_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var ViewerMixin_classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};











const ViewerMixin = (superClass) => {
    var _canvasSize, _effectMargins, _flattenedNodes, _handleNodeClick, _getNodeById;
    class Viewer extends NodeSelectableMixin(PositionedMixin(superClass)) {
        constructor(...args) {
            super(...args);
            this.zoomMargin = 50;
            this.link = "";
            // Cached values
            _canvasSize.set(this, void 0);
            _effectMargins.set(this, void 0);
            _flattenedNodes.set(this, void 0);
            _handleNodeClick.set(this, (node) => (ev) => {
                ev.preventDefault();
                ev.stopPropagation();
                this.selectedNode = node;
            });
            _getNodeById.set(this, (id) => {
                var _a, _b;
                return (_b = (_a = ViewerMixin_classPrivateFieldGet(this, _flattenedNodes)) === null || _a === void 0 ? void 0 : _a.find((n) => n.id === id)) !== null && _b !== void 0 ? _b : null;
            });
        }
        static get styles() {
            // @ts-ignore
            const styles = super.styles;
            return extendStyles(styles, [
                css `
          :host {
            --default-error-bg: #fff;
            --default-error-fg: #333;

            --bg: var(--figspec-viewer-bg, #e5e5e5);
            --z-index: var(--figspec-viewer-z-index, 0);
            --error-bg: var(--figspec-viewer-error-bg, var(--default-error-bg));
            --error-fg: var(--figspec-viewer-error-fg, var(--default-error-fg));
            --error-color: var(--figspec-viewer-error-color, tomato);

            --guide-thickness: var(--figspec-viewer-guide-thickness, 1.5px);
            --guide-color: var(--figspec-viewer-guide-color, tomato);
            --guide-selected-color: var(
              --figspec-viewer-guide-selected-color,
              dodgerblue
            );
            --guide-tooltip-fg: var(--figspec-viewer-guide-tooltip-fg, white);
            --guide-selected-tooltip-fg: var(
              --figspec-viewer-guide-selected-tooltip-fg,
              white
            );
            --guide-tooltip-bg: var(
              --figspec-viewer-guide-tooltip-bg,
              var(--guide-color)
            );
            --guide-selected-tooltip-bg: var(
              --figspec-viewer-guide-selected-tooltip-bg,
              var(--guide-selected-color)
            );
            --guide-tooltip-font-size: var(
              --figspec-viewer-guide-tooltip-font-size,
              12px
            );

            position: relative;
            display: block;

            background-color: var(--bg);
            user-select: none;
            overflow: hidden;
            z-index: var(--z-index);
          }

          @media (prefers-color-scheme: dark) {
            :host {
              --default-error-bg: #222;
              --default-error-fg: #fff;
            }
          }

          .spec-canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column-reverse;
          }

          .canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            flex: 1;
          }

          .rendered-image {
            position: absolute;
            top: 0;
            left: 0;
          }

          .guides {
            position: absolute;

            overflow: visible;
            stroke: var(--guide-color);
            fill: var(--guide-color);
            pointer-events: none;
            z-index: calc(var(--z-index) + 2);
          }
        `,
                Node_styles,
                ErrorMessage_styles,
                DistanceGuide_styles,
                InspectorView_styles,
                Footer_styles,
            ]);
        }
        get __images() {
            return {};
        }
        deselectNode() {
            this.selectedNode = null;
        }
        get error() {
            if (!ViewerMixin_classPrivateFieldGet(this, _canvasSize) || !ViewerMixin_classPrivateFieldGet(this, _flattenedNodes)) {
                return ErrorMessage({
                    title: "Error",
                    children: "Please call `__updateTree/1` method with a valid parameter.",
                });
            }
            return null;
        }
        render() {
            if (this.error) {
                if (this.error instanceof Error) {
                    return ErrorMessage({
                        title: this.error.name || "Error",
                        children: this.error.message,
                    });
                }
                if (typeof this.error === "string") {
                    return ErrorMessage({
                        title: "Error",
                        children: this.error,
                    });
                }
                return this.error;
            }
            const canvasSize = ViewerMixin_classPrivateFieldGet(this, _canvasSize);
            const reverseScale = 1 / this.scale;
            const guideThickness = `calc(var(--guide-thickness) * ${reverseScale})`;
            const computedGuideThickness = parseFloat(getComputedStyle(this).getPropertyValue("--guide-thickness"));
            const computedGuideTooltipFontSize = parseFloat(getComputedStyle(this).getPropertyValue("--guide-tooltip-font-size"));
            return lit_html.html `
        <div class="spec-canvas-wrapper" @click=${this.deselectNode}>
          <div
            class="canvas"
            style="
          width: ${canvasSize.width}px;
          height: ${canvasSize.height}px;

          transform: translate(-50%, -50%) ${this.canvasTransform.join(" ")}
        "
          >
            ${Object.entries(this.__images).map(([nodeId, uri]) => {
                var _a;
                const node = ViewerMixin_classPrivateFieldGet(this, _getNodeById).call(this, nodeId);
                if (!node ||
                    !("absoluteBoundingBox" in node) ||
                    !((_a = ViewerMixin_classPrivateFieldGet(this, _effectMargins)) === null || _a === void 0 ? void 0 : _a[node.id])) {
                    return null;
                }
                const margin = ViewerMixin_classPrivateFieldGet(this, _effectMargins)[node.id];
                return lit_html.html `
                <img class="rendered-image" src="${uri}"
                style=${styleMap({
                    top: `${node.absoluteBoundingBox.y - canvasSize.y}px`,
                    left: `${node.absoluteBoundingBox.x - canvasSize.x}px`,
                    marginTop: `${-margin.top}px`,
                    marginLeft: `${-margin.left}px`,
                    width: node.absoluteBoundingBox.width +
                        margin.left +
                        margin.right +
                        "px",
                    height: node.absoluteBoundingBox.height +
                        margin.top +
                        margin.bottom +
                        "px",
                })}"
                " />
              `;
            })}
            ${this.selectedNode &&
                Node_Tooltip({
                    nodeSize: this.selectedNode.absoluteBoundingBox,
                    offsetX: -canvasSize.x,
                    offsetY: -canvasSize.y,
                    reverseScale,
                })}
            ${lit_html.svg `
            <svg
              class="guides"
              viewBox="0 0 5 5"
              width="5"
              height="5"
              style=${styleMap({
                left: `${-canvasSize.x}px`,
                top: `${-canvasSize.y}px`,
                strokeWidth: guideThickness,
            })}
            >
              ${this.selectedNode &&
                Outline({
                    node: this.selectedNode,
                    selected: true,
                    computedThickness: computedGuideThickness * reverseScale,
                })}

              ${ViewerMixin_classPrivateFieldGet(this, _flattenedNodes).map((node) => {
                var _a;
                if (node.id === ((_a = this.selectedNode) === null || _a === void 0 ? void 0 : _a.id)) {
                    return null;
                }
                return lit_html.svg `
                  <g>
                    ${Outline({
                    node,
                    computedThickness: computedGuideThickness * reverseScale,
                    onClick: ViewerMixin_classPrivateFieldGet(this, _handleNodeClick).call(this, node),
                })}
                    ${this.selectedNode &&
                    Guides({
                        node,
                        distanceTo: this.selectedNode,
                        reverseScale,
                        fontSize: computedGuideTooltipFontSize,
                    })}
                  </g>
                `;
            })}
            </svg>
          `}
          </div>
          ${View({
                node: this.selectedNode,
                onClose: this.deselectNode,
            })}
          ${Footer(this.getMetadata())}
        </div>
      `;
        }
        // implemented in FileViewer/FrameViewer
        getMetadata() {
            return undefined;
        }
        connectedCallback() {
            super.connectedCallback();
            this.resetZoom();
        }
        updated(changedProperties) {
            super.updated(changedProperties);
        }
        __updateTree(node) {
            if (!(node.type === "CANVAS" ||
                node.type === "FRAME" ||
                node.type === "COMPONENT" ||
                //@ts-ignore NOTE: figma-js does not implement COMPONENT_SET type (yet?)
                node.type === "COMPONENT_SET")) {
                throw new Error("Cannot update node tree: Top level node MUST be one of CANVAS, FRAME, COMPONENT, or COMPONENT_SET");
            }
            ViewerMixin_classPrivateFieldSet(this, _canvasSize, node.type === "CANVAS" ? getCanvasSize(node) : node.absoluteBoundingBox);
            ViewerMixin_classPrivateFieldSet(this, _flattenedNodes, flattenNode(node));
            // Since above properties aren't "attribute", their changes does not
            // trigger an update. We need to manually request an update.
            this.requestUpdate();
        }
        __updateEffectMargins() {
            if (!this.__images) {
                return;
            }
            const containers = Object.keys(this.__images)
                .map(ViewerMixin_classPrivateFieldGet(this, _getNodeById))
                .filter((n) => !!n);
            ViewerMixin_classPrivateFieldSet(this, _effectMargins, containers.reduce((margin, node) => {
                if (!("absoluteBoundingBox" in node)) {
                    return margin;
                }
                return Object.assign(Object.assign({}, margin), { [node.id]: getEffectMargin(node, flattenNode(node)) });
            }, {}));
            this.requestUpdate();
        }
        resetZoom() {
            if (ViewerMixin_classPrivateFieldGet(this, _canvasSize)) {
                // Set initial zoom level based on element size
                const { width, height } = ViewerMixin_classPrivateFieldGet(this, _canvasSize);
                const { width: elementWidth, height: elementHeight, } = this.getBoundingClientRect();
                const wDiff = elementWidth / (width + this.zoomMargin * 2);
                const hDiff = elementHeight / (height + this.zoomMargin * 2);
                this.scale = Math.min(wDiff, hDiff, 1);
            }
        }
    }
    _canvasSize = new WeakMap(), _effectMargins = new WeakMap(), _flattenedNodes = new WeakMap(), _handleNodeClick = new WeakMap(), _getNodeById = new WeakMap();
    ViewerMixin_decorate([
        property({
            type: Number,
            attribute: "zoom-margin",
        })
    ], Viewer.prototype, "zoomMargin", void 0);
    ViewerMixin_decorate([
        property({
            type: String,
            attribute: "link",
        })
    ], Viewer.prototype, "link", void 0);
    return Viewer;
};
function getCanvasSize(node) {
    const left = [];
    const right = [];
    const top = [];
    const bottom = [];
    for (const child of node.children) {
        if (child.type !== "FRAME" && child.type !== "COMPONENT") {
            continue;
        }
        const { x, y, width, height } = child.absoluteBoundingBox;
        left.push(x);
        right.push(x + width);
        top.push(y);
        bottom.push(y + height);
    }
    const minX = Math.min(...left);
    const minY = Math.min(...top);
    return {
        x: minX,
        y: minY,
        width: Math.abs(Math.max(...right) - minX),
        height: Math.abs(Math.min(...bottom) - minY),
    };
}
function getEffectMargin(container, nodes) {
    const points = nodes.map((node) => {
        if (!("effects" in node)) {
            return {
                top: node.absoluteBoundingBox.y,
                right: node.absoluteBoundingBox.x + node.absoluteBoundingBox.width,
                bottom: node.absoluteBoundingBox.y + node.absoluteBoundingBox.height,
                left: node.absoluteBoundingBox.x,
            };
        }
        const blurRadiuses = node.effects
            .filter((effect) => effect.visible && effect.type === "LAYER_BLUR")
            .map((effect) => effect.radius);
        const shadowMargins = node.effects
            .filter((effect) => effect.visible && effect.type === "DROP_SHADOW" && !!effect.offset)
            .map((effect) => {
            return {
                left: effect.radius - effect.offset.x,
                top: effect.radius - effect.offset.y,
                right: effect.radius + effect.offset.x,
                bottom: effect.radius + effect.offset.y,
            };
        });
        const margin = {
            top: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.top)),
            right: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.right)),
            bottom: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.bottom)),
            left: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.left)),
        };
        return {
            top: node.absoluteBoundingBox.y - margin.top,
            right: node.absoluteBoundingBox.x +
                node.absoluteBoundingBox.width +
                margin.right,
            bottom: node.absoluteBoundingBox.y +
                node.absoluteBoundingBox.height +
                margin.bottom,
            left: node.absoluteBoundingBox.x - margin.left,
        };
    });
    const bounds = {
        top: Math.min(...points.map((p) => p.top)),
        right: Math.max(...points.map((p) => p.right)),
        bottom: Math.max(...points.map((p) => p.bottom)),
        left: Math.min(...points.map((p) => p.left)),
    };
    return {
        top: container.absoluteBoundingBox.y - bounds.top,
        right: bounds.right -
            container.absoluteBoundingBox.x -
            container.absoluteBoundingBox.width,
        bottom: bounds.bottom -
            container.absoluteBoundingBox.y -
            container.absoluteBoundingBox.height,
        left: container.absoluteBoundingBox.x - bounds.left,
    };
}
function flattenNode(node, depth = 0) {
    if (!("absoluteBoundingBox" in node)) {
        return node.children.map((child) => flattenNode(child, depth + 1)).flat();
    }
    if (!("children" in node) || node.children.length === 0) {
        return [Object.assign(Object.assign({}, node), { depth })];
    }
    return [
        Object.assign(Object.assign({}, node), { depth }),
        ...node.children.map((child) => flattenNode(child, depth + 1)).flat(),
    ];
}

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/FigspecFrameViewer.js
var FigspecFrameViewer_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




// TODO: Move docs for props in mixins (waiting for support at web-component-analyzer)
/**
 * A Figma spec viewer. Displays a rendered image alongside sizing guides.
 * @element figspec-frame-viewer
 *
 * @property {number} [panX=0]
 * Current pan offset in px for X axis.
 * This is a "before the scale" value.
 *
 * @property {number} [panY=0]
 * Current pan offset in px for Y axis.
 * This is a "before the scale" value.
 *
 * @property {number} [scale=1]
 * Current zoom level, where 1.0 = 100%.
 *
 * @property {number} [zoomSpeed=500]
 * How fast zooming when do ctrl+scroll / pinch gestures.
 * Available values: 1 ~ 1000
 * @attr [zoom-speed=500] See docs for `zoomSpeed` property.
 *
 * @property {number} [panSpeed=500]
 * How fast panning when scroll vertically or horizontally.
 * This does not affect to dragging with middle button pressed.
 * Available values: 1 ~ 1000.
 * @attr [pan-speed=500] See docs for `panSpeed` property.
 *
 * @property {Figma.Node | null} [selectedNode=null]
 * Current selected node.
 *
 * @property {string} [link=null]
 * Figma link for the given project/node. If passed, figspec will present a footer with metadata and a link to figma.
 *
 * @property {number} [zoomMargin=50]
 * The minimum margin for the preview canvas in px. Will be used when the preview
 * setting a default zooming scale for the canvas.
 * @attr [zoom-margin=50] See docs for `zoomMargin` property.
 *
 * @fires scalechange When a user zoom-in or zoom-out the preview.
 * @fires positionchange When a user panned the preview.
 * @fires nodeselect When a user selected / unselected a node.
 */
class FigspecFrameViewer extends ViewerMixin(LitElement) {
    constructor() {
        super(...arguments);
        /**
         * A response of "GET file nodes" API.
         * https://www.figma.com/developers/api#get-file-nodes-endpoint
         */
        this.nodes = null;
        /**
         * An image rendered by "GET image" API.
         * https://www.figma.com/developers/api#get-images-endpoint
         */
        this.renderedImage = null;
    }
    /** @private */
    get isMovable() {
        return !!(this.nodes && this.renderedImage && this.documentNode);
    }
    /**
     * Readonly. Document node (= root drawable node).
     * @readonly
     */
    get documentNode() {
        if (!this.nodes) {
            return null;
        }
        const documentNode = Object.values(this.nodes.nodes)[0];
        if (!documentNode || !("absoluteBoundingBox" in documentNode.document)) {
            return null;
        }
        return documentNode.document;
    }
    /** @private */
    get __images() {
        if (!this.documentNode || !this.renderedImage) {
            return {};
        }
        return {
            [this.documentNode.id]: this.renderedImage,
        };
    }
    /** @private */
    get error() {
        if (!this.nodes || !this.renderedImage) {
            return ErrorMessage({
                title: "Parameter error",
                children: lit_html.html `<span>
          Both <code>nodes</code> and <code>rendered-image</code> are required.
        </span>`,
            });
        }
        if (!this.documentNode) {
            return ErrorMessage({
                title: "Parameter Error",
                children: lit_html.html `
          <span> Document node is empty or does not have size. </span>
        `,
            });
        }
        if (super.error) {
            return super.error;
        }
    }
    getMetadata() {
        return {
            fileName: this.nodes.name,
            timestamp: this.nodes.lastModified,
            link: this.link,
        };
    }
    connectedCallback() {
        super.connectedCallback();
        if (this.documentNode) {
            this.__updateTree(this.documentNode);
            this.__updateEffectMargins();
            this.resetZoom();
        }
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (changedProperties.has("nodes")) {
            if (!this.documentNode)
                return;
            this.__updateTree(this.documentNode);
            this.resetZoom();
        }
        if (changedProperties.has("renderedImage")) {
            this.__updateEffectMargins();
        }
    }
}
FigspecFrameViewer_decorate([
    property({
        type: Object,
    })
], FigspecFrameViewer.prototype, "nodes", void 0);
FigspecFrameViewer_decorate([
    property({
        type: String,
        attribute: "rendered-image",
    })
], FigspecFrameViewer.prototype, "renderedImage", void 0);

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/FigspecViewer/FigspecFileViewer.js
var FigspecFileViewer_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FigspecFileViewer_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _selectFirstPage, _handlePageChange;





// TODO: Move docs for props in mixins (waiting for support at web-component-analyzer)
/**
 * A Figma spec viewer. Displays a rendered image alongside sizing guides.
 * @element figspec-file-viewer
 *
 * @property {number} [panX=0]
 * Current pan offset in px for X axis.
 * This is a "before the scale" value.
 *
 * @property {number} [panY=0]
 * Current pan offset in px for Y axis.
 * This is a "before the scale" value.
 *
 * @property {number} [scale=1]
 * Current zoom level, where 1.0 = 100%.
 *
 * @property {number} [zoomSpeed=500]
 * How fast zooming when do ctrl+scroll / pinch gestures.
 * Available values: 1 ~ 1000
 * @attr [zoom-speed=500] See docs for `zoomSpeed` property.
 *
 * @property {number} [panSpeed=500]
 * How fast panning when scroll vertically or horizontally.
 * This does not affect to dragging with middle button pressed.
 * Available values: 1 ~ 1000.
 * @attr [pan-speed=500] See docs for `panSpeed` property.
 *
 * @property {Figma.Node | null} [selectedNode=null]
 * Current selected node.
 *
 * @property {string} [link=null]
 * Figma link for the given project/node. If passed, figspec will present a footer with metadata and a link to figma.
 *
 * @property {number} [zoomMargin=50]
 * The minimum margin for the preview canvas in px. Will be used when the preview
 * setting a default zooming scale for the canvas.
 * @attr [zoom-margin=50] See docs for `zoomMargin` property.
 *
 * @fires scalechange When a user zoom-in or zoom-out the preview.
 * @fires positionchange When a user panned the preview.
 * @fires nodeselect When a user selected / unselected a node.
 */
class FigspecFileViewer extends ViewerMixin(LitElement) {
    constructor() {
        super(...arguments);
        /**
         * A response of "GET file nodes" API.
         * https://www.figma.com/developers/api#get-file-nodes-endpoint
         */
        this.documentNode = null;
        /**
         * A record of rendered images, where key is an ID of the node,
         * value is an URI of the image.
         * https://www.figma.com/developers/api#get-images-endpoint
         */
        this.renderedImages = null;
        /**
         * Current selected page (node whose type is "CANVAS").
         */
        this.selectedPage = null;
        _selectFirstPage.set(this, () => {
            var _a;
            if (!this.documentNode) {
                this.selectedPage = null;
                return;
            }
            this.selectedPage = (_a = this.documentNode.document.children.filter((c) => c.type === "CANVAS")[0]) !== null && _a !== void 0 ? _a : null;
        });
        _handlePageChange.set(this, (ev) => {
            var _a, _b;
            const target = ev.currentTarget;
            this.selectedPage = (_b = (_a = this.documentNode) === null || _a === void 0 ? void 0 : _a.document.children.find((c) => c.id === target.value)) !== null && _b !== void 0 ? _b : null;
            if (this.selectedPage) {
                this.__updateTree(this.selectedPage);
                this.resetZoom();
                this.__updateEffectMargins();
                this.panX = 0;
                this.panY = 0;
            }
        });
    }
    /** @private */
    get isMovable() {
        return !!(this.renderedImages && this.documentNode);
    }
    /** @private */
    get __images() {
        return this.renderedImages || {};
    }
    /** @private */
    get error() {
        if (!this.documentNode || !this.renderedImages) {
            return ErrorMessage({
                title: "Parameter error",
                children: lit_html.html `<span>
          Both <code>document-node</code> and <code>rendered-images</code> are
          required.
        </span>`,
            });
        }
        if (super.error) {
            return super.error;
        }
    }
    static get styles() {
        return extendStyles(super.styles, [
            css `
        :host {
          --figspec-control-bg-default: #fcfcfc;
          --figspec-control-fg-default: #333;

          --control-bg: var(
            --figspec-control-bg,
            var(--figspec-control-bg-default)
          );
          --control-fg: var(
            --figspec-control-bg,
            var(--figspec-control-fg-default)
          );
          --control-shadow: var(
            --figspec-control-shadow,
            0 2px 4px rgba(0, 0, 0, 0.3)
          );
          --padding: var(--figspec-control-padding, 8px 16px);

          display: flex;
          flex-direction: column;
        }

        @media (prefers-color-scheme: dark) {
          :host {
            --figspec-control-bg-default: #222;
            --figspec-control-fg-default: #fff;
          }
        }

        .controls {
          flex-shrink: 0;
          padding: var(--padding);

          background-color: var(--control-bg);
          box-shadow: var(--control-shadow);
          color: var(--control-fg);
          z-index: 1;
        }

        .view {
          position: relative;
          flex-grow: 1;
          flex-shrink: 1;
        }
      `,
        ]);
    }
    render() {
        var _a;
        return lit_html.html `
      <div class="controls">
        <select @change=${FigspecFileViewer_classPrivateFieldGet(this, _handlePageChange)}>
          ${(_a = this.documentNode) === null || _a === void 0 ? void 0 : _a.document.children.map((c) => lit_html.html `<option value=${c.id}>${c.name}</option>`)}
        </select>
      </div>

      <div class="view">${super.render()}</div>
    `;
    }
    getMetadata() {
        return {
            fileName: this.documentNode.name,
            timestamp: this.documentNode.lastModified,
            link: this.link,
        };
    }
    connectedCallback() {
        super.connectedCallback();
        if (this.documentNode) {
            FigspecFileViewer_classPrivateFieldGet(this, _selectFirstPage).call(this);
            if (this.selectedPage) {
                this.__updateTree(this.selectedPage);
                this.resetZoom();
            }
        }
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (changedProperties.has("documentNode")) {
            FigspecFileViewer_classPrivateFieldGet(this, _selectFirstPage).call(this);
            if (this.selectedPage) {
                this.__updateTree(this.selectedPage);
                this.resetZoom();
            }
        }
        if (changedProperties.has("renderedImages")) {
            this.__updateEffectMargins();
        }
    }
}
_selectFirstPage = new WeakMap(), _handlePageChange = new WeakMap();
FigspecFileViewer_decorate([
    property({
        type: Object,
        attribute: "document-node",
    })
], FigspecFileViewer.prototype, "documentNode", void 0);
FigspecFileViewer_decorate([
    property({
        type: Object,
        attribute: "rendered-images",
    })
], FigspecFileViewer.prototype, "renderedImages", void 0);

;// CONCATENATED MODULE: ./node_modules/@figspec/components/esm/es2015/index.js


if (!customElements.get("figspec-file-viewer")) {
    customElements.define("figspec-file-viewer", FigspecFileViewer);
}
if (!customElements.get("figspec-frame-viewer")) {
    customElements.define("figspec-frame-viewer", FigspecFrameViewer);
}



;// CONCATENATED MODULE: ./node_modules/@lit-labs/react/development/create-component.js
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const reservedReactProperties = new Set([
    'children',
    'localName',
    'ref',
    'style',
    'className',
]);
const listenedEvents = new WeakMap();
/**
 * Adds an event listener for the specified event to the given node. In the
 * React setup, there should only ever be one event listener. Thus, for
 * efficiency only one listener is added and the handler for that listener is
 * updated to point to the given listener function.
 */
const addOrUpdateEventListener = (node, event, listener) => {
    let events = listenedEvents.get(node);
    if (events === undefined) {
        listenedEvents.set(node, (events = new Map()));
    }
    let handler = events.get(event);
    if (listener !== undefined) {
        // If necessary, add listener and track handler
        if (handler === undefined) {
            events.set(event, (handler = { handleEvent: listener }));
            node.addEventListener(event, handler);
            // Otherwise just update the listener with new value
        }
        else {
            handler.handleEvent = listener;
        }
        // Remove listener if one exists and value is undefined
    }
    else if (handler !== undefined) {
        events.delete(event);
        node.removeEventListener(event, handler);
    }
};
/**
 * Sets properties and events on custom elements. These properties and events
 * have been pre-filtered so we know they should apply to the custom element.
 */
const setProperty = (node, name, value, old, events) => {
    const event = events === null || events === void 0 ? void 0 : events[name];
    if (event !== undefined) {
        // Dirty check event value.
        if (value !== old) {
            addOrUpdateEventListener(node, event, value);
        }
    }
    else {
        // But don't dirty check properties; elements are assumed to do this.
        node[name] = value;
    }
};
// Set a React ref. Note, there are 2 kinds of refs and there's no built in
// React API to set a ref.
const setRef = (ref, value) => {
    if (typeof ref === 'function') {
        ref(value);
    }
    else {
        ref.current = value;
    }
};
/**
 * Creates a React component for a custom element. Properties are distinguished
 * from attributes automatically, and events can be configured so they are
 * added to the custom element as event listeners.
 *
 * @param React The React module, typically imported from the `react` npm
 * package.
 * @param tagName The custom element tag name registered via
 * `customElements.define`.
 * @param elementClass The custom element class registered via
 * `customElements.define`.
 * @param events An object listing events to which the component can listen. The
 * object keys are the event property names passed in via React props and the
 * object values are the names of the corresponding events generated by the
 * custom element. For example, given `{onactivate: 'activate'}` an event
 * function may be passed via the component's `onactivate` prop and will be
 * called when the custom element fires its `activate` event.
 * @param displayName A React component display name, used in debugging
 * messages. Default value is inferred from the name of custom element class
 * registered via `customElements.define`.
 */
const createComponent = (React, tagName, elementClass, events, displayName) => {
    const Component = React.Component;
    const createElement = React.createElement;
    // Set of properties/events which should be specially handled by the wrapper
    // and not handled directly by React.
    const elementClassProps = new Set(Object.keys(events !== null && events !== void 0 ? events : {}));
    for (const p in elementClass.prototype) {
        if (!(p in HTMLElement.prototype)) {
            if (reservedReactProperties.has(p)) {
                // Note, this effectively warns only for `ref` since the other
                // reserved props are on HTMLElement.prototype. To address this
                // would require crawling down the prototype, which doesn't feel worth
                // it since implementing these properties on an element is extremely
                // rare.
                console.warn(`${tagName} contains property ${p} which is a React ` +
                    `reserved property. It will be used by React and not set on ` +
                    `the element.`);
            }
            else {
                elementClassProps.add(p);
            }
        }
    }
    class ReactComponent extends Component {
        constructor() {
            super(...arguments);
            this._element = null;
        }
        _updateElement(oldProps) {
            if (this._element === null) {
                return;
            }
            // Set element properties to the values in `this.props`
            for (const prop in this._elementProps) {
                setProperty(this._element, prop, this.props[prop], oldProps ? oldProps[prop] : undefined, events);
            }
            // Note, the spirit of React might be to "unset" any old values that
            // are no longer included; however, there's no reasonable value to set
            // them to so we just leave the previous state as is.
        }
        /**
         * Updates element properties correctly setting properties
         * on mount.
         */
        componentDidMount() {
            this._updateElement();
        }
        /**
         * Updates element properties correctly setting properties
         * on every update. Note, this does not include mount.
         */
        componentDidUpdate(old) {
            this._updateElement(old);
        }
        /**
         * Renders the custom element with a `ref` prop which allows this
         * component to reference the custom element.
         *
         * Standard attributes are passed to React and element properties and events
         * are updated in componentDidMount/componentDidUpdate.
         *
         */
        render() {
            // Since refs only get fulfilled once, pass a new one if the user's
            // ref changed. This allows refs to be fulfilled as expected, going from
            // having a value to null.
            const userRef = this.props.__forwardedRef;
            if (this._ref === undefined || this._userRef !== userRef) {
                this._ref = (value) => {
                    if (this._element === null) {
                        this._element = value;
                    }
                    if (userRef !== null) {
                        setRef(userRef, value);
                    }
                    this._userRef = userRef;
                };
            }
            // Filters class properties out and passes the remaining
            // attributes to React. This allows attributes to use framework rules
            // for setting attributes and render correctly under SSR.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const props = { ref: this._ref };
            // Note, save element props while iterating to avoid the need to
            // iterate again when setting properties.
            this._elementProps = {};
            for (const [k, v] of Object.entries(this.props)) {
                if (k === '__forwardedRef')
                    continue;
                if (elementClassProps.has(k)) {
                    this._elementProps[k] = v;
                }
                else {
                    // React does *not* handle `className` for custom elements so
                    // coerce it to `class` so it's handled correctly.
                    props[k === 'className' ? 'class' : k] = v;
                }
            }
            return createElement(tagName, props);
        }
    }
    ReactComponent.displayName = displayName !== null && displayName !== void 0 ? displayName : elementClass.name;
    const ForwardedComponent = React.forwardRef((props, ref) => createElement(ReactComponent, { ...props, __forwardedRef: ref }, props === null || props === void 0 ? void 0 : props.children));
    // To ease debugging in the React Developer Tools
    ForwardedComponent.displayName = ReactComponent.displayName;
    return ForwardedComponent;
};
//# sourceMappingURL=create-component.js.map
;// CONCATENATED MODULE: ./node_modules/@lit-labs/react/development/index.js
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@figspec/react/esm/es2015/index.js



// NOTE: These exported components are casted with `as unknown as ...` in order not to break
//       typings accidentally. `as unknown` is required because a component created by
//       `createComponent` has `RefAttributes<unknown>`, which is incompatible with existing
//       type signature (and breaks ref typings). Also the explicit props definition prevents
//       every properties turns into optional.
const es2015_FigspecFrameViewer = createComponent(react_namespaceObject, "figspec-frame-viewer", FigspecFrameViewer, {
    onNodeSelect: "nodeselect",
    onPositionChange: "positionchange",
    onScaleChange: "scalechange",
});
const es2015_FigspecFileViewer = createComponent(react_namespaceObject, "figspec-file-viewer", FigspecFileViewer, {
    onNodeSelect: "nodeselect",
    onPositionChange: "positionchange",
    onScaleChange: "scalechange",
});

// EXTERNAL MODULE: ./node_modules/@storybook/ui/node_modules/@storybook/components/dist/esm/placeholder/placeholder.js
var placeholder = __webpack_require__("./node_modules/@storybook/ui/node_modules/@storybook/components/dist/esm/placeholder/placeholder.js");
// EXTERNAL MODULE: ./node_modules/@emotion/core/dist/core.browser.esm.js + 5 modules
var core_browser_esm = __webpack_require__("./node_modules/@emotion/core/dist/core.browser.esm.js");
// EXTERNAL MODULE: ./node_modules/storybook-addon-designs/esm/register/components/Figma.js
var Figma = __webpack_require__("./node_modules/storybook-addon-designs/esm/register/components/Figma.js");
;// CONCATENATED MODULE: ./node_modules/storybook-addon-designs/esm/register/components/Figspec.js
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
var __makeTemplateObject = (undefined && undefined.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Figspec_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};





var fullscreen = (0,core_browser_esm.css)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n"], ["\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n"])));
function unwrapJson(res) {
    return res.status !== 200 ? Promise.reject(res.statusText) : res.json();
}
function getAccessToken(cfg) {
    var _a;
    if (cfg.accessToken) {
        return cfg.accessToken;
    }
    try {
        return (_a = process.env.STORYBOOK_FIGMA_ACCESS_TOKEN) !== null && _a !== void 0 ? _a : null;
    }
    catch (err) {
        return null;
    }
}
var Figspec = function (_a) {
    var config = _a.config;
    var _b = (0,react.useState)({
        state: 'loading',
    }), state = _b[0], setState = _b[1];
    var fetchDetails = function (signal) { return Figspec_awaiter(void 0, void 0, void 0, function () {
        var match, fileKey, url, nodeId, accessToken, headers, nodeUrl, imageUrl, documentNode, frames_1, images_1, _a, nodes, images, err_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    setState({ state: 'loading' });
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, , 7]);
                    match = config.url.match(Figma.figmaURLPattern);
                    if (!match) {
                        throw new Error(config.url + ' is not a valid Figma URL.');
                    }
                    fileKey = match[3];
                    url = new URL(config.url);
                    nodeId = url.searchParams.get('node-id');
                    accessToken = getAccessToken(config);
                    if (!accessToken) {
                        throw new Error('Personal Access Token is required.');
                    }
                    headers = {
                        'X-FIGMA-TOKEN': accessToken,
                    };
                    nodeUrl = new URL("https://api.figma.com/v1/files/" + fileKey);
                    imageUrl = new URL("https://api.figma.com/v1/images/" + fileKey);
                    imageUrl.searchParams.set('format', 'svg');
                    if (!!nodeId) return [3, 4];
                    return [4, fetch(nodeUrl.href, {
                            headers: headers,
                            signal: signal,
                        }).then(unwrapJson)];
                case 2:
                    documentNode = _b.sent();
                    frames_1 = listAllFrames(documentNode.document);
                    imageUrl.searchParams.set('ids', frames_1.map(function (frame) { return frame.id; }).join(','));
                    return [4, fetch(imageUrl.href, {
                            headers: headers,
                            signal: signal,
                        }).then(unwrapJson)];
                case 3:
                    images_1 = _b.sent();
                    setState({
                        state: 'fetched',
                        value: {
                            type: 'file',
                            props: {
                                documentNode: documentNode,
                                renderedImages: images_1.images,
                                link: config.url
                            },
                        },
                    });
                    return [2];
                case 4:
                    nodeUrl.pathname += '/nodes';
                    nodeUrl.searchParams.set('ids', nodeId);
                    imageUrl.searchParams.set('ids', nodeId);
                    return [4, Promise.all([
                            fetch(nodeUrl.href, {
                                headers: headers,
                                signal: signal,
                            }).then(unwrapJson),
                            fetch(imageUrl.href, { headers: headers, signal: signal }).then(unwrapJson),
                        ])];
                case 5:
                    _a = _b.sent(), nodes = _a[0], images = _a[1];
                    setState({
                        state: 'fetched',
                        value: {
                            type: 'frame',
                            props: {
                                nodes: nodes,
                                renderedImage: Object.values(images.images)[0],
                                link: config.url
                            },
                        },
                    });
                    return [3, 7];
                case 6:
                    err_1 = _b.sent();
                    if (err_1 instanceof DOMException && err_1.code === DOMException.ABORT_ERR) {
                        return [2];
                    }
                    console.error(err_1);
                    setState({
                        state: 'failed',
                        error: err_1 instanceof Error ? err_1.message : String(err_1),
                    });
                    return [3, 7];
                case 7: return [2];
            }
        });
    }); };
    (0,react.useEffect)(function () {
        var fulfilled = false;
        var fulfil = function () {
            fulfilled = true;
        };
        var ac = new AbortController();
        fetchDetails(ac.signal).then(fulfil, fulfil);
        return function () {
            if (!fulfilled) {
                ac.abort();
            }
        };
    }, [config.url]);
    switch (state.state) {
        case 'loading':
            return ((0,core_browser_esm.jsx)(placeholder.Placeholder, null,
                (0,core_browser_esm.jsx)(react.Fragment, null, "Loading Figma file...")));
        case 'failed':
            return ((0,core_browser_esm.jsx)(placeholder.Placeholder, null,
                (0,core_browser_esm.jsx)(react.Fragment, null, "Failed to load Figma file"),
                (0,core_browser_esm.jsx)(react.Fragment, null, state.error)));
        case 'fetched':
            return state.value.type === 'file' ? ((0,core_browser_esm.jsx)(es2015_FigspecFileViewer, __assign({ css: fullscreen }, state.value.props))) : ((0,core_browser_esm.jsx)(es2015_FigspecFrameViewer, __assign({ css: fullscreen }, state.value.props)));
    }
};
/* harmony default export */ const components_Figspec = (Figspec);
function listAllFrames(node) {
    if ('absoluteBoundingBox' in node) {
        return [node];
    }
    if (!node.children || node.children.length === 0) {
        return [];
    }
    return node.children.map(listAllFrames).flat();
}
var templateObject_1;


/***/ })

}]);