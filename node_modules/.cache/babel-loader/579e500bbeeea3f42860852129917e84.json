{"ast":null,"code":"import \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport { baseApi } from './websocketServiceBaseApi';\nimport { URL_PATHS } from '@luma-fe-workspace/utility';\nimport { Stomp } from '@stomp/stompjs';\nconst injectedWebsocketApi = baseApi.injectEndpoints({\n  endpoints: builder => ({\n    getMessages: builder.query({\n      queryFn: () => ({\n        data: []\n      }),\n\n      //we do not care about the initial query so we do not need basequery\n      async onCacheEntryAdded(props, {\n        cacheEntryRemoved,\n        updateCachedData\n      }) {\n        //we ensure user is authenticated before hitting the server as the JWT is required\n        if (props.token) {\n          const client = Stomp.client(props.baseClientURL); //Instantiate\n\n          let connected = false; //setting up header for authentication\n\n          const header = {\n            Authorization: `Bearer ${props.token}`\n          };\n          client.connect(header, data => {\n            //subscription to a channel that is session based\n            const sessionId = data.headers['user-name'];\n            const destination = `/user/${sessionId}/stream/${props.destination}`;\n            const headers = {\n              sessionId\n            };\n\n            if (sessionId) {\n              connected = true;\n            }\n\n            client.subscribe(destination, message => {\n              if (message.body) {\n                // populate the array with messages as they are received from the websocket\n                updateCachedData(draft => {\n                  draft.push(JSON.parse(message.body));\n                });\n              }\n            }, headers);\n          }, error => console.log('=====SERVER HAS ERROR', {\n            error\n          }), cb => {\n            connected = cb.target.readyState === 3 ? false : true;\n            console.log('===============CONNECTION CLOSED - EVENT', cb);\n          }); // autoreconnect once detected connection drop\n\n          client.reconnectDelay = 3000; //reconnect every 5000ms\n          //setTimeout is use to turn off auto reconnection if issue persist 11 seconds after - 11000ms is chosen to at least have autoreconnect to try 3 times\n\n          setTimeout(() => {\n            //by this time if connected is still false then auto reconnect did not work\n            if (!connected) {\n              console.log('====NOT CONNECTED AND AUTO RECONNECT FAILED===DEACTIVATING.......', {\n                connected\n              });\n              client.deactivate();\n              client.forceDisconnect();\n            }\n          }, 11000); //disconnect - if you are not on any secondaries path\n\n          !props.currentPath.includes(URL_PATHS.SECONDARIES) && client.disconnect(() => console.log('CLIENT HAS BEEN DISCONNECTED!!'));\n          await cacheEntryRemoved;\n        } else {\n          //if you were connected already and you signout - you need to disconnect\n          Stomp.client(props.baseClientURL).disconnect(() => console.log('CLIENT HAS BEEN DISCONNECTED!!'));\n        }\n      }\n\n    })\n  })\n});\nexport { injectedWebsocketApi as websocketServiceApi };\nexport const {\n  useGetMessagesQuery\n} = injectedWebsocketApi;","map":{"version":3,"names":["baseApi","URL_PATHS","Stomp","injectedWebsocketApi","injectEndpoints","endpoints","builder","getMessages","query","queryFn","data","onCacheEntryAdded","props","cacheEntryRemoved","updateCachedData","token","client","baseClientURL","connected","header","Authorization","connect","sessionId","headers","destination","subscribe","message","body","draft","push","JSON","parse","error","console","log","cb","target","readyState","reconnectDelay","setTimeout","deactivate","forceDisconnect","currentPath","includes","SECONDARIES","disconnect","websocketServiceApi","useGetMessagesQuery"],"sources":["/Users/jchen/Documents/GitHub/luma-fe-workspace/libs/redux/src/redux/websocketService/websocketServiceEndpoints.ts"],"sourcesContent":["import { baseApi } from './websocketServiceBaseApi';\nimport { URL_PATHS } from '@luma-fe-workspace/utility';\nimport { Stomp } from '@stomp/stompjs';\n\nexport interface WebsocketProps {\n  baseClientURL: string;\n  token: string;\n  destination: string;\n  currentPath: string;\n}\n\nconst injectedWebsocketApi = baseApi.injectEndpoints({\n  endpoints: (builder) => ({\n    getMessages: builder.query<any, WebsocketProps>({\n      queryFn: () => ({ data: [] }), //we do not care about the initial query so we do not need basequery\n      async onCacheEntryAdded(props, { cacheEntryRemoved, updateCachedData }) {\n        //we ensure user is authenticated before hitting the server as the JWT is required\n        if (props.token) {\n          const client = Stomp.client(props.baseClientURL); //Instantiate\n          let connected = false;\n          //setting up header for authentication\n          const header = {\n            Authorization: `Bearer ${props.token}`,\n          };\n          client.connect(\n            header,\n            (data: any) => {\n              //subscription to a channel that is session based\n              const sessionId = data.headers['user-name'];\n              const destination = `/user/${sessionId}/stream/${props.destination}`;\n              const headers = { sessionId };\n              if (sessionId) {\n                connected = true;\n              }\n\n              client.subscribe(\n                destination,\n                (message) => {\n                  if (message.body) {\n                    // populate the array with messages as they are received from the websocket\n                    updateCachedData((draft) => {\n                      draft.push(JSON.parse(message.body));\n                    });\n                  }\n                },\n                headers\n              );\n            },\n            (error: any) => console.log('=====SERVER HAS ERROR', { error }),\n            (cb: { target: { readyState: number } }) => {\n              connected = cb.target.readyState === 3 ? false : true;\n              console.log('===============CONNECTION CLOSED - EVENT', cb);\n            }\n          );\n\n          // autoreconnect once detected connection drop\n          client.reconnectDelay = 3000; //reconnect every 5000ms\n\n          //setTimeout is use to turn off auto reconnection if issue persist 11 seconds after - 11000ms is chosen to at least have autoreconnect to try 3 times\n          setTimeout(() => {\n            //by this time if connected is still false then auto reconnect did not work\n            if (!connected) {\n              console.log(\n                '====NOT CONNECTED AND AUTO RECONNECT FAILED===DEACTIVATING.......',\n                { connected }\n              );\n              client.deactivate();\n              client.forceDisconnect();\n            }\n          }, 11000);\n\n          //disconnect - if you are not on any secondaries path\n          !props.currentPath.includes(URL_PATHS.SECONDARIES) &&\n            client.disconnect(() =>\n              console.log('CLIENT HAS BEEN DISCONNECTED!!')\n            );\n\n          await cacheEntryRemoved;\n        } else {\n          //if you were connected already and you signout - you need to disconnect\n          Stomp.client(props.baseClientURL).disconnect(() =>\n            console.log('CLIENT HAS BEEN DISCONNECTED!!')\n          );\n        }\n      },\n    }),\n  }),\n});\nexport { injectedWebsocketApi as websocketServiceApi };\nexport const { useGetMessagesQuery } = injectedWebsocketApi;\n"],"mappings":";;;AAAA,SAASA,OAAT,QAAwB,2BAAxB;AACA,SAASC,SAAT,QAA0B,4BAA1B;AACA,SAASC,KAAT,QAAsB,gBAAtB;AASA,MAAMC,oBAAoB,GAAGH,OAAO,CAACI,eAAR,CAAwB;EACnDC,SAAS,EAAGC,OAAD,KAAc;IACvBC,WAAW,EAAED,OAAO,CAACE,KAAR,CAAmC;MAC9CC,OAAO,EAAE,OAAO;QAAEC,IAAI,EAAE;MAAR,CAAP,CADqC;;MACf;MAC/B,MAAMC,iBAAN,CAAwBC,KAAxB,EAA+B;QAAEC,iBAAF;QAAqBC;MAArB,CAA/B,EAAwE;QACtE;QACA,IAAIF,KAAK,CAACG,KAAV,EAAiB;UACf,MAAMC,MAAM,GAAGd,KAAK,CAACc,MAAN,CAAaJ,KAAK,CAACK,aAAnB,CAAf,CADe,CACmC;;UAClD,IAAIC,SAAS,GAAG,KAAhB,CAFe,CAGf;;UACA,MAAMC,MAAM,GAAG;YACbC,aAAa,EAAG,UAASR,KAAK,CAACG,KAAM;UADxB,CAAf;UAGAC,MAAM,CAACK,OAAP,CACEF,MADF,EAEGT,IAAD,IAAe;YACb;YACA,MAAMY,SAAS,GAAGZ,IAAI,CAACa,OAAL,CAAa,WAAb,CAAlB;YACA,MAAMC,WAAW,GAAI,SAAQF,SAAU,WAAUV,KAAK,CAACY,WAAY,EAAnE;YACA,MAAMD,OAAO,GAAG;cAAED;YAAF,CAAhB;;YACA,IAAIA,SAAJ,EAAe;cACbJ,SAAS,GAAG,IAAZ;YACD;;YAEDF,MAAM,CAACS,SAAP,CACED,WADF,EAEGE,OAAD,IAAa;cACX,IAAIA,OAAO,CAACC,IAAZ,EAAkB;gBAChB;gBACAb,gBAAgB,CAAEc,KAAD,IAAW;kBAC1BA,KAAK,CAACC,IAAN,CAAWC,IAAI,CAACC,KAAL,CAAWL,OAAO,CAACC,IAAnB,CAAX;gBACD,CAFe,CAAhB;cAGD;YACF,CATH,EAUEJ,OAVF;UAYD,CAvBH,EAwBGS,KAAD,IAAgBC,OAAO,CAACC,GAAR,CAAY,uBAAZ,EAAqC;YAAEF;UAAF,CAArC,CAxBlB,EAyBGG,EAAD,IAA4C;YAC1CjB,SAAS,GAAGiB,EAAE,CAACC,MAAH,CAAUC,UAAV,KAAyB,CAAzB,GAA6B,KAA7B,GAAqC,IAAjD;YACAJ,OAAO,CAACC,GAAR,CAAY,0CAAZ,EAAwDC,EAAxD;UACD,CA5BH,EAPe,CAsCf;;UACAnB,MAAM,CAACsB,cAAP,GAAwB,IAAxB,CAvCe,CAuCe;UAE9B;;UACAC,UAAU,CAAC,MAAM;YACf;YACA,IAAI,CAACrB,SAAL,EAAgB;cACde,OAAO,CAACC,GAAR,CACE,mEADF,EAEE;gBAAEhB;cAAF,CAFF;cAIAF,MAAM,CAACwB,UAAP;cACAxB,MAAM,CAACyB,eAAP;YACD;UACF,CAVS,EAUP,KAVO,CAAV,CA1Ce,CAsDf;;UACA,CAAC7B,KAAK,CAAC8B,WAAN,CAAkBC,QAAlB,CAA2B1C,SAAS,CAAC2C,WAArC,CAAD,IACE5B,MAAM,CAAC6B,UAAP,CAAkB,MAChBZ,OAAO,CAACC,GAAR,CAAY,gCAAZ,CADF,CADF;UAKA,MAAMrB,iBAAN;QACD,CA7DD,MA6DO;UACL;UACAX,KAAK,CAACc,MAAN,CAAaJ,KAAK,CAACK,aAAnB,EAAkC4B,UAAlC,CAA6C,MAC3CZ,OAAO,CAACC,GAAR,CAAY,gCAAZ,CADF;QAGD;MACF;;IAvE6C,CAAnC;EADU,CAAd;AADwC,CAAxB,CAA7B;AA6EA,SAAS/B,oBAAoB,IAAI2C,mBAAjC;AACA,OAAO,MAAM;EAAEC;AAAF,IAA0B5C,oBAAhC"},"metadata":{},"sourceType":"module"}