{"ast":null,"code":"import \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  message: {\n    title: '',\n    messageType: 'success',\n    isMessageShowing: false\n  },\n  pendingActionOrders: [],\n  pendingExecutionDetails: []\n};\nexport const secondariesSlice = createSlice({\n  name: 'secondaries',\n  initialState,\n  reducers: {\n    setSecurityDetailsCusip(state, action) {\n      state.securityDetailsCusip = action.payload;\n    },\n\n    setMessageObject(state, action) {\n      state.message = action.payload;\n    },\n\n    setIsMessageShowing(state, action) {\n      state.message.isMessageShowing = action.payload;\n    },\n\n    setAllRFQs(state, action) {\n      const RFQs = action.payload.RFQs;\n      const userName = action.payload.userName;\n\n      if (RFQs) {\n        const availableRFQs = [];\n        const myRFQs = [];\n        const RFQsSorted = RFQs.slice().sort((a, b) => {\n          if (a.requestId && b.requestId) {\n            return b.requestId - a.requestId;\n          }\n\n          return 0;\n        });\n        RFQsSorted.forEach(RFQ => {\n          // Checking for requestId since we've seen broken data without it.\n          if (!RFQ.requestId) return;\n\n          if (RFQ.createdByUserId === userName) {\n            myRFQs.push(RFQ);\n          } else {\n            availableRFQs.push(RFQ);\n          }\n        });\n        state.myRFQs = myRFQs;\n        state.availableRFQs = availableRFQs;\n      }\n    },\n\n    setMyRFQs(state, action) {\n      state.myRFQs = action.payload;\n    },\n\n    setAvailableRFQs(state, action) {\n      state.availableRFQs = action.payload;\n    },\n\n    updateMyRFQs(state, action) {\n      if (state.myRFQs) {\n        const updatedRFQs = state.myRFQs.map(existingRFQ => {\n          const updatedRFQ = action.payload.RFQs.find(newRFQ => existingRFQ.requestId === newRFQ.requestId);\n\n          if (updatedRFQ) {\n            return updatedRFQ;\n          }\n\n          return existingRFQ;\n        });\n        state.myRFQs = updatedRFQs;\n      } else {\n        state.myRFQs = action.payload.RFQs;\n      }\n    },\n\n    updateOrAddToAvailableRFQs(state, action) {\n      const incomingRFQs = action.payload;\n\n      if (!state.availableRFQs) {\n        // If no existing RFQs, add all\n        state.availableRFQs = incomingRFQs;\n        return;\n      }\n\n      const availableRFQs = [...state.availableRFQs];\n      incomingRFQs.forEach(newRFQ => {\n        const existingRFQIndex = availableRFQs.findIndex(RFQ => RFQ.requestId === newRFQ.requestId);\n\n        if (availableRFQs[existingRFQIndex]) {\n          // If RFQ exists, update\n          availableRFQs[existingRFQIndex] = newRFQ;\n        } else {\n          // If RFQ is new, add\n          availableRFQs.push(newRFQ);\n        }\n      });\n      state.availableRFQs = availableRFQs;\n    },\n\n    setAllOrders(state, action) {\n      state.orders = action.payload;\n    },\n\n    addOrUpdateOrders(state, action) {\n      const newOrder = action.payload;\n      state.orders = [...[...(state.orders || [])].filter(order => order.orderId !== newOrder.orderId), newOrder];\n    },\n\n    addToPendingActionOrders(state, action) {\n      state.pendingActionOrders = [...state.pendingActionOrders, action.payload];\n    },\n\n    removeFromPendingActionOrders(state, action) {\n      const removedOrder = action.payload;\n      state.pendingActionOrders = state.pendingActionOrders.filter(order => order.orderId !== removedOrder.orderId);\n    },\n\n    addToPendingExecutionDetails(state, action) {\n      state.pendingExecutionDetails = [...state.pendingExecutionDetails, action.payload];\n    },\n\n    removeFromPendingExecutionDetails(state, action) {\n      const removedOrder = action.payload;\n      state.pendingExecutionDetails = state.pendingExecutionDetails.filter(order => order.orderId !== removedOrder.orderId);\n    }\n\n  }\n});","map":{"version":3,"names":["createSlice","initialState","message","title","messageType","isMessageShowing","pendingActionOrders","pendingExecutionDetails","secondariesSlice","name","reducers","setSecurityDetailsCusip","state","action","securityDetailsCusip","payload","setMessageObject","setIsMessageShowing","setAllRFQs","RFQs","userName","availableRFQs","myRFQs","RFQsSorted","slice","sort","a","b","requestId","forEach","RFQ","createdByUserId","push","setMyRFQs","setAvailableRFQs","updateMyRFQs","updatedRFQs","map","existingRFQ","updatedRFQ","find","newRFQ","updateOrAddToAvailableRFQs","incomingRFQs","existingRFQIndex","findIndex","setAllOrders","orders","addOrUpdateOrders","newOrder","filter","order","orderId","addToPendingActionOrders","removeFromPendingActionOrders","removedOrder","addToPendingExecutionDetails","removeFromPendingExecutionDetails"],"sources":["/Users/jchen/Documents/GitHub/luma-fe-workspace/libs/redux/src/redux/secondaries/slice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport {\n  SecondaryOrder,\n  SecondaryRequestForQuote,\n} from '../secondariesService/secondariesServiceEndpoints';\nimport { SecondariesMessageObject } from './types';\n\ninterface SecondariesState {\n  securityDetailsCusip?: string;\n  message: SecondariesMessageObject;\n  myRFQs?: SecondaryRequestForQuote[];\n  availableRFQs?: SecondaryRequestForQuote[];\n  orders?: SecondaryOrder[];\n  pendingActionOrders: SecondaryOrder[];\n  pendingExecutionDetails: SecondaryOrder[];\n}\n\nconst initialState: SecondariesState = {\n  message: {\n    title: '',\n    messageType: 'success',\n    isMessageShowing: false,\n  },\n  pendingActionOrders: [],\n  pendingExecutionDetails: [],\n};\n\nexport const secondariesSlice = createSlice({\n  name: 'secondaries',\n  initialState,\n  reducers: {\n    setSecurityDetailsCusip(state, action: PayloadAction<string | undefined>) {\n      state.securityDetailsCusip = action.payload;\n    },\n    setMessageObject(state, action: PayloadAction<SecondariesMessageObject>) {\n      state.message = action.payload;\n    },\n    setIsMessageShowing(state, action: PayloadAction<boolean>) {\n      state.message.isMessageShowing = action.payload;\n    },\n    setAllRFQs(\n      state,\n      action: PayloadAction<{\n        RFQs: SecondaryRequestForQuote[];\n        userName: string;\n      }>\n    ) {\n      const RFQs = action.payload.RFQs;\n      const userName = action.payload.userName;\n      if (RFQs) {\n        const availableRFQs: SecondaryRequestForQuote[] = [];\n        const myRFQs: SecondaryRequestForQuote[] = [];\n        const RFQsSorted = RFQs.slice().sort((a, b) => {\n          if (a.requestId && b.requestId) {\n            return b.requestId - a.requestId;\n          }\n          return 0;\n        });\n        RFQsSorted.forEach((RFQ) => {\n          // Checking for requestId since we've seen broken data without it.\n          if (!RFQ.requestId) return;\n          if (RFQ.createdByUserId === userName) {\n            myRFQs.push(RFQ);\n          } else {\n            availableRFQs.push(RFQ);\n          }\n        });\n        state.myRFQs = myRFQs;\n        state.availableRFQs = availableRFQs;\n      }\n    },\n    setMyRFQs(state, action: PayloadAction<SecondaryRequestForQuote[]>) {\n      state.myRFQs = action.payload;\n    },\n    setAvailableRFQs(state, action: PayloadAction<SecondaryRequestForQuote[]>) {\n      state.availableRFQs = action.payload;\n    },\n    updateMyRFQs(\n      state,\n      action: PayloadAction<{\n        RFQs: SecondaryRequestForQuote[];\n      }>\n    ) {\n      if (state.myRFQs) {\n        const updatedRFQs = state.myRFQs.map((existingRFQ) => {\n          const updatedRFQ = action.payload.RFQs.find(\n            (newRFQ) => existingRFQ.requestId === newRFQ.requestId\n          );\n          if (updatedRFQ) {\n            return updatedRFQ;\n          }\n          return existingRFQ;\n        });\n        state.myRFQs = updatedRFQs;\n      } else {\n        state.myRFQs = action.payload.RFQs;\n      }\n    },\n    updateOrAddToAvailableRFQs(\n      state,\n      action: PayloadAction<SecondaryRequestForQuote[]>\n    ) {\n      const incomingRFQs = action.payload;\n      if (!state.availableRFQs) {\n        // If no existing RFQs, add all\n        state.availableRFQs = incomingRFQs;\n        return;\n      }\n      const availableRFQs = [...state.availableRFQs];\n      incomingRFQs.forEach((newRFQ) => {\n        const existingRFQIndex = availableRFQs.findIndex(\n          (RFQ) => RFQ.requestId === newRFQ.requestId\n        );\n        if (availableRFQs[existingRFQIndex]) {\n          // If RFQ exists, update\n          availableRFQs[existingRFQIndex] = newRFQ;\n        } else {\n          // If RFQ is new, add\n          availableRFQs.push(newRFQ);\n        }\n      });\n      state.availableRFQs = availableRFQs;\n    },\n    setAllOrders(state, action: PayloadAction<SecondaryOrder[]>) {\n      state.orders = action.payload;\n    },\n    addOrUpdateOrders(state, action: PayloadAction<SecondaryOrder>) {\n      const newOrder = action.payload;\n      state.orders = [\n        ...[...(state.orders || [])].filter(\n          (order) => order.orderId !== newOrder.orderId\n        ),\n        newOrder,\n      ];\n    },\n    addToPendingActionOrders(state, action: PayloadAction<SecondaryOrder>) {\n      state.pendingActionOrders = [\n        ...state.pendingActionOrders,\n        action.payload,\n      ];\n    },\n    removeFromPendingActionOrders(\n      state,\n      action: PayloadAction<SecondaryOrder>\n    ) {\n      const removedOrder = action.payload;\n      state.pendingActionOrders = state.pendingActionOrders.filter(\n        (order) => order.orderId !== removedOrder.orderId\n      );\n    },\n    addToPendingExecutionDetails(state, action: PayloadAction<SecondaryOrder>) {\n      state.pendingExecutionDetails = [\n        ...state.pendingExecutionDetails,\n        action.payload,\n      ];\n    },\n    removeFromPendingExecutionDetails(\n      state,\n      action: PayloadAction<SecondaryOrder>\n    ) {\n      const removedOrder = action.payload;\n      state.pendingExecutionDetails = state.pendingExecutionDetails.filter(\n        (order) => order.orderId !== removedOrder.orderId\n      );\n    },\n  },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}