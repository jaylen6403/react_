"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileSwc = void 0;
const devkit_1 = require("@nrwl/devkit");
const child_process_1 = require("child_process");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const print_diagnostics_1 = require("../typescript/print-diagnostics");
const run_type_check_1 = require("../typescript/run-type-check");
function compileSwc(context, normalizedOptions, postCompilationCallback) {
    devkit_1.logger.log(`Compiling with SWC for ${context.projectName}...`);
    const srcPath = `../${normalizedOptions.swcCliOptions.projectDir}`;
    let swcCmd = `npx swc ${srcPath} -d ${normalizedOptions.swcCliOptions.destPath} --source-maps --no-swcrc --config-file=${normalizedOptions.swcrcPath}`;
    const postCompilationOperator = () => (0, operators_1.concatMap)(({ success }) => {
        if (success) {
            return postCompilationCallback().then(() => ({ success }));
        }
        return rxjs_1.EMPTY;
    });
    const compile$ = new rxjs_1.Observable((subscriber) => {
        if (normalizedOptions.watch) {
            swcCmd += ' --watch';
            const watchProcess = createSwcWatchProcess(swcCmd, normalizedOptions.projectRoot, (success) => {
                subscriber.next({ success });
            });
            return () => {
                watchProcess.close();
                subscriber.complete();
            };
        }
        const swcCmdLog = (0, child_process_1.execSync)(swcCmd, {
            cwd: normalizedOptions.projectRoot,
        }).toString();
        devkit_1.logger.log(swcCmdLog.replace(/\n/, ''));
        subscriber.next({ success: swcCmdLog.includes('Successfully compiled') });
        return () => {
            subscriber.complete();
        };
    });
    if (normalizedOptions.skipTypeCheck) {
        return compile$.pipe(postCompilationOperator());
    }
    const tsOptions = {
        outputPath: normalizedOptions.outputPath,
        projectName: context.projectName,
        projectRoot: normalizedOptions.projectRoot,
        tsConfig: normalizedOptions.tsConfig,
        watch: normalizedOptions.watch,
    };
    const outDir = tsOptions.outputPath.replace(`/${tsOptions.projectRoot}`, '');
    const typeCheck$ = new rxjs_1.Observable((subscriber) => {
        const typeCheckOptions = {
            mode: 'emitDeclarationOnly',
            tsConfigPath: tsOptions.tsConfig,
            outDir,
            workspaceRoot: normalizedOptions.root,
        };
        if (normalizedOptions.watch) {
            let typeCheckRunner;
            let preEmit = false;
            (0, run_type_check_1.runTypeCheckWatch)(typeCheckOptions, (diagnostic, formattedDiagnostic, errorCount) => {
                // 6031 and 6032 are to skip watchCompilerHost initialization (Start watching for changes... message)
                // We also skip if preEmit has been set to true, because it means that the first type check before
                // the WatchCompiler emits.
                if (preEmit && diagnostic.code !== 6031 && diagnostic.code !== 6032) {
                    const hasErrors = errorCount > 0;
                    if (hasErrors) {
                        void (0, print_diagnostics_1.printDiagnostics)([formattedDiagnostic]);
                    }
                    else {
                        void (0, print_diagnostics_1.printDiagnostics)([], [formattedDiagnostic]);
                    }
                    subscriber.next({ success: !hasErrors });
                }
            }).then(({ close, preEmitErrors, preEmitWarnings }) => {
                const hasErrors = preEmitErrors.length > 0;
                if (hasErrors) {
                    void (0, print_diagnostics_1.printDiagnostics)(preEmitErrors, preEmitWarnings);
                }
                typeCheckRunner = { close };
                subscriber.next({ success: !hasErrors });
                preEmit = true;
            });
            return () => {
                if (typeCheckRunner) {
                    typeCheckRunner.close();
                }
                subscriber.complete();
            };
        }
        (0, run_type_check_1.runTypeCheck)(typeCheckOptions).then(({ errors, warnings }) => {
            const hasErrors = errors.length > 0;
            if (hasErrors) {
                void (0, print_diagnostics_1.printDiagnostics)(errors, warnings);
            }
            subscriber.next({ success: !hasErrors });
            subscriber.complete();
        });
        return () => {
            subscriber.complete();
        };
    });
    return (0, rxjs_1.zip)(compile$, typeCheck$).pipe((0, operators_1.map)(([compileResult, typeCheckResult]) => ({
        success: compileResult.success && typeCheckResult.success,
    })), postCompilationOperator());
}
exports.compileSwc = compileSwc;
function createSwcWatchProcess(swcCmd, cwd, callback) {
    const watchProcess = (0, child_process_1.exec)(swcCmd, { cwd });
    watchProcess.stdout.on('data', (data) => {
        process.stdout.write(data);
        callback(data.includes('Successfully compiled'));
    });
    watchProcess.stderr.on('data', (err) => {
        process.stderr.write(err);
        callback(false);
    });
    const processExitListener = () => watchProcess.kill();
    process.on('SIGINT', processExitListener);
    process.on('SIGTERM', processExitListener);
    process.on('exit', processExitListener);
    watchProcess.on('exit', () => {
        callback(true);
    });
    return { close: () => watchProcess.kill() };
}
//# sourceMappingURL=compile-swc.js.map