"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addLint = exports.projectGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const run_tasks_in_serial_1 = require("@nrwl/workspace/src/utilities/run-tasks-in-serial");
const path_1 = require("path");
const add_swc_config_1 = require("./swc/add-swc-config");
const add_swc_dependencies_1 = require("./swc/add-swc-dependencies");
// nx-ignore-next-line
const { jestProjectGenerator } = require('@nrwl/jest');
// nx-ignore-next-line
const { lintProjectGenerator, Linter } = require('@nrwl/linter');
function projectGenerator(tree, schema, destinationDir, filesDir, projectType) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const options = normalizeOptions(tree, schema, destinationDir);
        createFiles(tree, options, filesDir);
        addProject(tree, options, destinationDir, projectType);
        if (!schema.skipTsConfig) {
            updateRootTsConfig(tree, options);
        }
        const tasks = [];
        if (options.linter !== 'none') {
            const lintCallback = yield addLint(tree, options);
            tasks.push(lintCallback);
        }
        if (options.unitTestRunner === 'jest') {
            const jestCallback = yield addJest(tree, options);
            tasks.push(jestCallback);
        }
        if (!options.skipFormat) {
            yield (0, devkit_1.formatFiles)(tree);
        }
        return (0, run_tasks_in_serial_1.runTasksInSerial)(...tasks);
    });
}
exports.projectGenerator = projectGenerator;
function addProject(tree, options, destinationDir, projectType) {
    const projectConfiguration = {
        root: options.projectRoot,
        sourceRoot: (0, devkit_1.joinPathFragments)(options.projectRoot, 'src'),
        projectType: projectType,
        targets: {},
        tags: options.parsedTags,
    };
    if (options.buildable && options.config != 'npm-scripts') {
        projectConfiguration.targets.build = {
            executor: `@nrwl/js:${options.compiler}`,
            outputs: ['{options.outputPath}'],
            options: {
                outputPath: `dist/${destinationDir}/${options.projectDirectory}`,
                main: `${options.projectRoot}/src/index` + (options.js ? '.js' : '.ts'),
                tsConfig: `${options.projectRoot}/${projectType === 'library' ? 'tsconfig.lib.json' : 'tsconfig.app.json'}`,
                assets: [`${options.projectRoot}/*.md`],
            },
        };
        if (options.compiler === 'swc' && options.skipTypeCheck) {
            projectConfiguration.targets.build.options.skipTypeCheck = true;
        }
        if (projectType === 'application') {
            projectConfiguration.targets.serve = {
                executor: `@nrwl/js:node`,
                options: {
                    buildTarget: `${options.name}:build`,
                },
            };
        }
    }
    if (options.config === 'workspace') {
        (0, devkit_1.addProjectConfiguration)(tree, options.name, projectConfiguration, false);
    }
    else if (options.config === 'project') {
        (0, devkit_1.addProjectConfiguration)(tree, options.name, projectConfiguration, true);
    }
    else {
        (0, devkit_1.addProjectConfiguration)(tree, options.name, {
            root: projectConfiguration.root,
            tags: projectConfiguration.tags,
        }, true);
    }
}
function addLint(tree, options) {
    return lintProjectGenerator(tree, {
        project: options.name,
        linter: options.linter,
        skipFormat: true,
        tsConfigPaths: [
            (0, devkit_1.joinPathFragments)(options.projectRoot, 'tsconfig.lib.json'),
        ],
        eslintFilePatterns: [
            `${options.projectRoot}/**/*.${options.js ? 'js' : 'ts'}`,
        ],
        setParserOptionsProject: options.setParserOptionsProject,
    });
}
exports.addLint = addLint;
function updateTsConfig(tree, options) {
    (0, devkit_1.updateJson)(tree, (0, path_1.join)(options.projectRoot, 'tsconfig.json'), (json) => {
        if (options.strict) {
            json.compilerOptions = Object.assign(Object.assign({}, json.compilerOptions), { forceConsistentCasingInFileNames: true, strict: true, noImplicitOverride: true, noPropertyAccessFromIndexSignature: true, noImplicitReturns: true, noFallthroughCasesInSwitch: true });
        }
        return json;
    });
}
function createFiles(tree, options, filesDir) {
    const { className, name, propertyName } = (0, devkit_1.names)(options.name);
    (0, devkit_1.generateFiles)(tree, filesDir, options.projectRoot, Object.assign(Object.assign({}, options), { dot: '.', className,
        name,
        propertyName, js: !!options.js, cliCommand: 'nx', strict: undefined, tmpl: '', offsetFromRoot: (0, devkit_1.offsetFromRoot)(options.projectRoot), buildable: options.buildable === true, hasUnitTestRunner: options.unitTestRunner !== 'none' }));
    if (options.buildable && options.compiler === 'swc') {
        (0, add_swc_dependencies_1.addSwcDependencies)(tree);
        (0, add_swc_config_1.addSwcConfig)(tree, options.projectRoot);
    }
    if (options.unitTestRunner === 'none') {
        tree.delete((0, path_1.join)(options.projectRoot, 'src/lib', `${options.fileName}.spec.ts`));
        tree.delete((0, path_1.join)(options.projectRoot, 'src/app', `${options.fileName}.spec.ts`));
    }
    if (options.js) {
        (0, devkit_1.toJS)(tree);
    }
    const packageJsonPath = (0, path_1.join)(options.projectRoot, 'package.json');
    if (options.config === 'npm-scripts') {
        (0, devkit_1.updateJson)(tree, packageJsonPath, (json) => {
            json.scripts = {
                build: "echo 'implement build'",
                test: "echo 'implement test'",
            };
            return json;
        });
    }
    else if (!options.buildable) {
        tree.delete(packageJsonPath);
    }
    updateTsConfig(tree, options);
}
function addJest(tree, options) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return yield jestProjectGenerator(tree, {
            project: options.name,
            setupFile: 'none',
            supportTsx: false,
            skipSerializers: true,
            testEnvironment: options.testEnvironment,
            skipFormat: true,
            compiler: options.compiler,
        });
    });
}
function normalizeOptions(tree, options, destinationDir) {
    if (options.config === 'npm-scripts') {
        options.unitTestRunner = 'none';
        options.linter = Linter.None;
        options.buildable = false;
    }
    if (options.compiler === 'swc' && options.skipTypeCheck == null) {
        options.skipTypeCheck = false;
    }
    const name = (0, devkit_1.names)(options.name).fileName;
    const projectDirectory = options.directory
        ? `${(0, devkit_1.names)(options.directory).fileName}/${name}`
        : name;
    if (!options.unitTestRunner && options.config !== 'npm-scripts') {
        options.unitTestRunner = 'jest';
    }
    if (!options.linter && options.config !== 'npm-scripts') {
        options.linter = Linter.EsLint;
    }
    const projectName = projectDirectory.replace(new RegExp('/', 'g'), '-');
    const fileName = getCaseAwareFileName({
        fileName: options.simpleModuleName ? name : projectName,
        pascalCaseFiles: options.pascalCaseFiles,
    });
    const { npmScope } = (0, devkit_1.getWorkspaceLayout)(tree);
    const projectRoot = (0, devkit_1.joinPathFragments)(destinationDir, projectDirectory);
    const parsedTags = options.tags
        ? options.tags.split(',').map((s) => s.trim())
        : [];
    const defaultImportPath = `@${npmScope}/${projectDirectory}`;
    const importPath = options.importPath || defaultImportPath;
    return Object.assign(Object.assign({}, options), { fileName, name: projectName, projectRoot,
        projectDirectory,
        parsedTags,
        importPath });
}
function getCaseAwareFileName(options) {
    const normalized = (0, devkit_1.names)(options.fileName);
    return options.pascalCaseFiles ? normalized.className : normalized.fileName;
}
function updateRootTsConfig(host, options) {
    (0, devkit_1.updateJson)(host, 'tsconfig.base.json', (json) => {
        const c = json.compilerOptions;
        c.paths = c.paths || {};
        delete c.paths[options.name];
        if (c.paths[options.importPath]) {
            throw new Error(`You already have a library using the import path "${options.importPath}". Make sure to specify a unique one.`);
        }
        c.paths[options.importPath] = [
            (0, devkit_1.joinPathFragments)(options.projectRoot, './src', 'index.' + (options.js ? 'js' : 'ts')),
        ];
        return json;
    });
}
//# sourceMappingURL=project-generator.js.map