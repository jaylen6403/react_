"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts_dedent_1 = require("ts-dedent");
const path_1 = __importDefault(require("path"));
const proper_url_join_1 = __importDefault(require("proper-url-join"));
// eslint-disable-next-line import/default
const update_notifier_1 = __importDefault(require("update-notifier"));
const stories_1 = require("./storybook/stories");
const start_app_1 = require("./storybook/start-app");
const create_hyperlink_1 = require("./util/create-hyperlink");
const package_json_1 = require("../package.json");
const logger_1 = require("./util/logger");
const csf_1 = require("@storybook/csf");
const IFRAME_PATH = "iframe.html";
const DEFAULT_SOURCE_URL = "http://localhost:6006";
update_notifier_1.default({
    pkg: {
        name: package_json_1.name,
        version: package_json_1.version
    },
    updateCheckInterval: 0,
    shouldNotifyInNpmScript: true
}).notify();
const checkStorybook = (url, { errorMessage }) => __awaiter(void 0, void 0, void 0, function* () {
    if (!(yield start_app_1.checkResponse(url))) {
        throw new Error(ts_dedent_1.dedent `
            No Storybook server responding at ${url}
            ${errorMessage}
        `);
    }
    logger_1.getLogger().info(`Detected Storybook at ${url}`);
});
const isPathsEqual = (path1, path2) => path_1.default.normalize(path1) === path_1.default.normalize(path2);
const getComponentNameFromFilePath = (filePath) => {
    let componentName = null;
    const filename = path_1.default.basename(filePath, path_1.default.extname(filePath));
    if (filename === "index") {
        const parts = path_1.default.dirname(filePath).split(path_1.default.sep);
        componentName = parts[parts.length - 1];
    }
    else {
        componentName = filename;
    }
    return componentName.charAt(0)
        .toUpperCase()
        .concat(componentName.slice(1))
        .replace(/-([a-z])/, (_, match) => match.toUpperCase());
};
class default_1 {
    constructor() {
        this.stories = [];
        this.targetUrl = "";
        this.sourceUrl = "";
        this.config = {};
    }
    init(pluginContext) {
        return __awaiter(this, void 0, void 0, function* () {
            this.config = pluginContext.config || {};
            const { url = DEFAULT_SOURCE_URL, fetchStories = true, targetUrl, startScript, command, useDocsPage, failFastOnErrors, ignoreSSLErrors } = this.config;
            this.sourceUrl = url.endsWith(IFRAME_PATH) ? url : proper_url_join_1.default(url, IFRAME_PATH);
            this.targetUrl = targetUrl || url;
            this.useDocsPage = useDocsPage;
            logger_1.setLogger(pluginContext.logger);
            const logger = logger_1.getLogger();
            if (!fetchStories) {
                logger.info("Fetching stories from Storybook instance is disabled.");
                return;
            }
            if (!startScript && !command) {
                yield checkStorybook(this.sourceUrl, { errorMessage: "Make sure you've started it and it is accessible." });
                this.stories = yield stories_1.loadStoriesFromURL(this.sourceUrl, { ignoreSSLErrors, failFastOnErrors });
            }
            else {
                const sbProcess = yield start_app_1.startApp({
                    args: ["--ci"],
                    scriptName: startScript,
                    commandName: command,
                    url: this.sourceUrl,
                    inheritStdio: false
                });
                yield checkStorybook(this.sourceUrl, {
                    errorMessage: "Make sure url parameter targets the instance started by startScript or command."
                });
                try {
                    this.stories = yield stories_1.loadStoriesFromURL(this.sourceUrl, { ignoreSSLErrors, failFastOnErrors });
                }
                catch (e) {
                    logger.debug(e.stack);
                    logger.info("Could not load stories from Storybook.");
                    if (failFastOnErrors) {
                        logger.debug("Fast fail is enabled. Abortingâ€¦");
                        throw new Error("Could not load stories from Storybook.");
                    }
                }
                finally {
                    sbProcess === null || sbProcess === void 0 ? void 0 : sbProcess.kill();
                }
            }
            if (this.storiesLoaded()) {
                logger.info(`Loaded ${this.stories.length} stories from Storybook.`);
            }
        });
    }
    get metadata() {
        return {
            storybook: {
                url: this.targetUrl
            }
        };
    }
    getStoriesFromStorybook(componentFilePath) {
        const componentNameFromFilePath = getComponentNameFromFilePath(componentFilePath);
        return this.stories.filter(story => {
            const { displayName: storyDisplayName, component, filePath: storyFilePath } = story;
            return isPathsEqual(componentFilePath, component.filePath) ||
                isPathsEqual(componentFilePath, storyFilePath) ||
                component.name === componentNameFromFilePath ||
                storyDisplayName === componentNameFromFilePath;
        });
    }
    toStory(story, kind) {
        return {
            storyId: csf_1.toId(kind, story),
            kind,
            name: story,
            hasDocsPage: this.useDocsPage || false
        };
    }
    getStoriesFromComponentConfig({ kind, stories }) {
        if (!kind) {
            return [];
        }
        if (!stories) {
            return this.stories.filter(story => story.kind === kind);
        }
        return stories.reduce((acc, storyName) => {
            const foundStory = this.stories.find(story => story.kind === kind && story.name === storyName);
            acc.push(foundStory || this.toStory(storyName, kind));
            return acc;
        }, []);
    }
    process(componentConfig) {
        const storybookConfig = componentConfig.storybook || {};
        const selectedStories = (storybookConfig.kind
            ? this.getStoriesFromComponentConfig(storybookConfig)
            : this.getStoriesFromStorybook(componentConfig.path));
        const links = selectedStories.map(story => this.createLink(story));
        return Promise.resolve({ links });
    }
    supports(x) {
        return this.storiesLoaded() || !!x.storybook;
    }
    storiesLoaded() {
        return this.stories.length > 0;
    }
    createLink({ storyId, name: storyName, kind, hasDocsPage }) {
        return {
            type: "storybook" /* storybook */,
            url: create_hyperlink_1.createStoryHyperlink(this.targetUrl, {
                storyId,
                selectedStory: storyName,
                selectedKind: kind,
                hasDocsPage
            }, {
                format: this.config.format,
                useDocsPage: this.useDocsPage
            }),
            metadata: {
                storybook: {
                    kind,
                    story: storyName
                }
            }
        };
    }
}
exports.default = default_1;
//# sourceMappingURL=index.js.map