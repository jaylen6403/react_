"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connectComponentConfigFiles = void 0;
const chalk_1 = __importDefault(require("chalk"));
const ts_dedent_1 = __importDefault(require("ts-dedent"));
const import_from_1 = __importDefault(require("import-from"));
const path_1 = __importDefault(require("path"));
const url_join_1 = __importDefault(require("url-join"));
const errors_1 = require("../../errors");
const defaults_1 = require("../../config/defaults");
const logger_1 = __importDefault(require("../../util/logger"));
const package_1 = require("../../util/package");
const text_1 = require("../../util/text");
const array_1 = require("../../util/array");
const object_1 = require("../../util/object");
const importPlugin = (pluginName) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Workaround to retrieve plugins for initializer
        const pluginInCwd = import_from_1.default.silent("node_modules", pluginName);
        if (pluginInCwd) {
            return pluginInCwd.default;
        }
        return (yield Promise.resolve().then(() => __importStar(require(pluginName)))).default;
    }
    catch (e) {
        const error = new errors_1.CLIError((0, ts_dedent_1.default) `
            Could not find plugin ${chalk_1.default.bold(pluginName)} failed.
            Please make sure that it's ${(0, package_1.isRunningFromGlobal)() ? "globally " : ""}installed and try again.
                ${(0, text_1.getInstallCommand)(pluginName)}
        `);
        error.stack = e.stack;
        throw error;
    }
});
const createPluginInstance = (plugin, components) => __awaiter(void 0, void 0, void 0, function* () {
    const PluginClass = yield importPlugin(plugin.name);
    const pluginInstance = new PluginClass();
    logger_1.default.debug(`Initializing ${plugin.name}.`);
    // Check that plugin implements the required functions
    if (!(typeof pluginInstance.process === "function") ||
        !(typeof pluginInstance.supports === "function")) {
        throw new errors_1.CLIError((0, ts_dedent_1.default) `
                ${chalk_1.default.bold(plugin.name)} does not conform Connected Components plugin interface.
                Please make sure that the plugin implements the requirements listed on the documentation.
                https://github.com/zeplin/cli/blob/master/PLUGIN.md
        `);
    }
    pluginInstance.name = plugin.name;
    if (typeof pluginInstance.init === "function") {
        logger_1.default.debug(`${plugin.name} has init method. Initializing with ${JSON.stringify(plugin.config)}`);
        yield pluginInstance.init({ config: plugin.config, components, logger: logger_1.default });
    }
    return pluginInstance;
});
const initializePlugins = (plugins, components) => __awaiter(void 0, void 0, void 0, function* () {
    const imports = plugins.map(plugin => createPluginInstance(plugin, components));
    const pluginInstances = yield Promise.all(imports);
    return pluginInstances;
});
const linkTypes = [
    "github" /* github */,
    "bitbucket" /* bitbucket */,
    "gitlab" /* gitlab */,
    "storybook" /* storybook */,
    "custom" /* custom */
];
const processLink = (link) => {
    if (!linkTypes.includes(link.type)) {
        link.type = "custom" /* custom */;
    }
    link.url = encodeURI(link.url);
    return link;
};
const createRepoLink = (componentPath, gitConfig, repoDefaults) => {
    const url = gitConfig.url || repoDefaults.url;
    const { repository } = gitConfig;
    const branch = gitConfig.branch || repoDefaults.branch;
    const basePath = gitConfig.path || "";
    const prefix = repoDefaults.prefix || "";
    const filePath = componentPath.split(path_1.default.sep);
    return {
        type: repoDefaults.type,
        url: encodeURI((0, url_join_1.default)(url, repository, prefix, branch, basePath, ...filePath))
    };
};
const createBitbucketLink = (componentPath, bitbucketConfig) => {
    const { url = defaults_1.defaults.bitbucket.url, repository, branch = "", project = "", user = "", path: basePath = "" } = bitbucketConfig;
    const isCloud = url === defaults_1.defaults.bitbucket.url;
    const filePath = componentPath.split(path_1.default.sep);
    let preparedUrl;
    if (isCloud) {
        const prefix = defaults_1.defaults.bitbucket.cloudPrefix;
        preparedUrl = (0, url_join_1.default)(url, user, repository, prefix, branch, basePath, ...filePath);
    }
    else {
        const owner = project
            ? { path: "projects", name: project }
            : { path: "users", name: user };
        preparedUrl = (0, url_join_1.default)(url, owner.path, owner.name, "repos", repository, "browse", basePath, ...filePath);
        if (branch) {
            preparedUrl += `?at=${branch}`;
        }
    }
    return {
        type: defaults_1.defaults.bitbucket.type,
        url: encodeURI(preparedUrl)
    };
};
const createRepoLinks = (componentPath, componentConfigFile) => {
    const repoLinks = [];
    if (componentConfigFile.github) {
        repoLinks.push(createRepoLink(componentPath, componentConfigFile.github, defaults_1.defaults.github));
    }
    if (componentConfigFile.gitlab) {
        repoLinks.push(createRepoLink(componentPath, componentConfigFile.gitlab, defaults_1.defaults.gitlab));
    }
    if (componentConfigFile.bitbucket) {
        repoLinks.push(createBitbucketLink(componentPath, componentConfigFile.bitbucket));
    }
    return repoLinks;
};
const componentConfigToConnectedComponentItems = ({ component, links, description, code }) => [
    ...(component.zeplinNames || []).map(pattern => ({
        pattern,
        name: component.name,
        description,
        filePath: component.path,
        code,
        links
    })),
    ...(component.zeplinIds || []).map(componentId => ({
        componentId,
        name: component.name,
        description,
        filePath: component.path,
        code,
        links
    }))
];
const createLinksFromConfigFile = (component, componentConfigFile) => (componentConfigFile.links || []).map(({ name, type, url }) => {
    if (component[type]) {
        const customUrlPath = component[type].urlPath;
        if (customUrlPath) {
            return { name, type: "custom" /* custom */, url: (0, url_join_1.default)(url, customUrlPath) };
        }
    }
    return undefined;
}).filter(object_1.isDefined);
const processPlugin = (plugin, component) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        if (!plugin.supports(component)) {
            logger_1.default.debug(`${plugin.name} does not support ${component.path}.`);
            return {};
        }
        logger_1.default.debug(`${plugin.name} supports ${component.path}. Processingâ€¦`);
        const componentData = yield plugin.process(component);
        logger_1.default.debug(`${plugin.name} processed ${component.path}: ${componentData}`);
        return {
            code: (componentData.snippet
                ? {
                    snippet: componentData.snippet,
                    lang: componentData.lang
                }
                : undefined),
            description: componentData.description,
            links: (componentData.links || []).map(processLink)
        };
    }
    catch (err) {
        throw new errors_1.CLIError((0, ts_dedent_1.default) `
                Error occurred while processing ${chalk_1.default.bold(component.path)} with ${chalk_1.default.bold(plugin.name)}:

                ${err.message}
            `, err.stack);
    }
});
const connectComponentConfig = (component, componentConfigFile, plugins) => __awaiter(void 0, void 0, void 0, function* () {
    // Execute all plugins
    const pluginResponses = (yield Promise.all(plugins.map(plugin => processPlugin(plugin, component))))
        .filter(object_1.isDefined);
    const links = [
        ...createLinksFromConfigFile(component, componentConfigFile),
        ...createRepoLinks(component.path, componentConfigFile),
        ...pluginResponses.reduce((acc, response) => {
            if (response.links) {
                return [...acc, ...response.links];
            }
            return acc;
        }, [])
    ];
    const codeAndDescriptions = pluginResponses.reduce((acc, response) => {
        if (("code" in response && response.code) ||
            ("description" in response && response.description)) {
            return [...acc, { code: response.code, description: response.description }];
        }
        return acc;
    }, []);
    if (codeAndDescriptions.length === 0) {
        codeAndDescriptions.push({});
    }
    return (0, array_1.flat)(codeAndDescriptions.map(codeAndDescription => componentConfigToConnectedComponentItems(Object.assign({ component,
        links }, codeAndDescription))));
});
const getMetadata = (plugins = []) => (plugins.reduce((acc, plugin) => {
    if (!plugin.metadata) {
        return acc;
    }
    return Object.assign(Object.assign({}, acc), plugin.metadata);
}, {}));
const connectComponentConfigFile = (componentConfigFile) => __awaiter(void 0, void 0, void 0, function* () {
    const { components } = componentConfigFile;
    const plugins = yield initializePlugins(componentConfigFile.plugins || [], components);
    const items = (0, array_1.flat)(yield Promise.all(components.map(component => connectComponentConfig(component, componentConfigFile, plugins))));
    return {
        projects: componentConfigFile.projects || [],
        styleguides: componentConfigFile.styleguides || [],
        items,
        metadata: getMetadata(plugins)
    };
});
const connectComponentConfigFiles = (componentConfigFiles) => {
    const promises = componentConfigFiles.map(componentConfigFile => connectComponentConfigFile(componentConfigFile));
    return Promise.all(promises);
};
exports.connectComponentConfigFiles = connectComponentConfigFiles;
