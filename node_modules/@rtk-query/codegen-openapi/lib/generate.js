"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateApi = exports.getOverrides = void 0;
const typescript_1 = __importDefault(require("typescript"));
const path = __importStar(require("path"));
const lodash_1 = require("lodash");
const generate_1 = __importStar(require("oazapfts/lib/codegen/generate"));
const tscodegen_1 = require("oazapfts/lib/codegen/tscodegen");
const react_hooks_1 = require("./generators/react-hooks");
const utils_1 = require("./utils");
const codegen_1 = require("./codegen");
const factory_1 = require("./utils/factory");
const generatedApiName = 'injectedRtkApi';
function defaultIsDataResponse(code) {
    const parsedCode = Number(code);
    return !Number.isNaN(parsedCode) && parsedCode >= 200 && parsedCode < 300;
}
function getOperationName({ verb, path, operation }) {
    return (0, generate_1.getOperationName)(verb, path, operation.operationId);
}
function patternMatches(pattern) {
    const filters = Array.isArray(pattern) ? pattern : [pattern];
    return function matcher(operationName) {
        if (!pattern)
            return true;
        return filters.some((filter) => typeof filter === 'string' ? filter === operationName : filter === null || filter === void 0 ? void 0 : filter.test(operationName));
    };
}
function operationMatches(pattern) {
    const checkMatch = typeof pattern === 'function' ? pattern : patternMatches(pattern);
    return function matcher(operationDefinition) {
        if (!pattern)
            return true;
        const operationName = getOperationName(operationDefinition);
        return checkMatch(operationName, operationDefinition);
    };
}
function getOverrides(operation, endpointOverrides) {
    return endpointOverrides === null || endpointOverrides === void 0 ? void 0 : endpointOverrides.find((override) => operationMatches(override.pattern)(operation));
}
exports.getOverrides = getOverrides;
async function generateApi(spec, { apiFile, apiImport = 'api', exportName = 'enhancedApi', argSuffix = 'ApiArg', responseSuffix = 'ApiResponse', hooks = false, outputFile, isDataResponse = defaultIsDataResponse, filterEndpoints, endpointOverrides, }) {
    const v3Doc = await (0, utils_1.getV3Doc)(spec);
    const apiGen = new generate_1.default(v3Doc, {});
    const operationDefinitions = (0, utils_1.getOperationDefinitions)(v3Doc).filter(operationMatches(filterEndpoints));
    const resultFile = typescript_1.default.createSourceFile('someFileName.ts', '', typescript_1.default.ScriptTarget.Latest, 
    /*setParentNodes*/ false, typescript_1.default.ScriptKind.TS);
    const printer = typescript_1.default.createPrinter({ newLine: typescript_1.default.NewLineKind.LineFeed });
    const interfaces = {};
    function registerInterface(declaration) {
        const name = declaration.name.escapedText.toString();
        if (name in interfaces) {
            throw new Error(`interface/type alias ${name} already registered`);
        }
        interfaces[name] = declaration;
        return declaration;
    }
    if (outputFile) {
        outputFile = path.resolve(process.cwd(), outputFile);
        if (apiFile.startsWith('.')) {
            apiFile = path.relative(path.dirname(outputFile), apiFile);
            if (!apiFile.startsWith('.'))
                apiFile = './' + apiFile;
        }
    }
    apiFile = apiFile.replace(/\.[jt]sx?$/, '');
    const sourceCode = printer.printNode(typescript_1.default.EmitHint.Unspecified, factory_1.factory.createSourceFile([
        (0, codegen_1.generateImportNode)(apiFile, { [apiImport]: 'api' }),
        (0, codegen_1.generateCreateApiCall)({
            endpointDefinitions: factory_1.factory.createObjectLiteralExpression(operationDefinitions.map((operationDefinition) => generateEndpoint({
                operationDefinition,
                overrides: getOverrides(operationDefinition, endpointOverrides),
            })), true),
        }),
        factory_1.factory.createExportDeclaration(undefined, undefined, false, factory_1.factory.createNamedExports([
            factory_1.factory.createExportSpecifier(factory_1.factory.createIdentifier(generatedApiName), factory_1.factory.createIdentifier(exportName)),
        ]), undefined),
        ...Object.values(interfaces),
        ...apiGen['aliases'],
        ...(hooks
            ? [(0, react_hooks_1.generateReactHooks)({ exportName: generatedApiName, operationDefinitions, endpointOverrides })]
            : []),
    ], factory_1.factory.createToken(typescript_1.default.SyntaxKind.EndOfFileToken), typescript_1.default.NodeFlags.None), resultFile);
    return sourceCode;
    function generateEndpoint({ operationDefinition, overrides, }) {
        const { verb, path, pathItem, operation, operation: { responses, requestBody }, } = operationDefinition;
        const operationName = getOperationName({ verb, path, operation });
        const isQuery = (0, utils_1.isQuery)(verb, overrides);
        const returnsJson = apiGen.getResponseType(responses) === 'json';
        let ResponseType = factory_1.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.UnknownKeyword);
        if (returnsJson) {
            const returnTypes = Object.entries(responses || {})
                .map(([code, response]) => [
                code,
                apiGen.resolve(response),
                apiGen.getTypeFromResponse(response) || factory_1.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.UndefinedKeyword),
            ])
                .filter(([status, response]) => isDataResponse(status, apiGen.resolve(response), responses || {}))
                .map(([code, response, type]) => typescript_1.default.addSyntheticLeadingComment({ ...type }, typescript_1.default.SyntaxKind.MultiLineCommentTrivia, `* status ${code} ${response.description} `, false))
                .filter((type) => type !== tscodegen_1.keywordType.void);
            if (returnTypes.length > 0) {
                ResponseType = factory_1.factory.createUnionTypeNode(returnTypes);
            }
        }
        const ResponseTypeName = factory_1.factory.createTypeReferenceNode(registerInterface(factory_1.factory.createTypeAliasDeclaration(undefined, [factory_1.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)], (0, utils_1.capitalize)(operationName + responseSuffix), undefined, ResponseType)).name);
        const parameters = (0, generate_1.supportDeepObjects)([
            ...apiGen.resolveArray(pathItem.parameters),
            ...apiGen.resolveArray(operation.parameters),
        ]);
        const allNames = parameters.map((p) => p.name);
        const queryArg = {};
        for (const param of parameters) {
            const isPureSnakeCase = /^[a-zA-Z][a-zA-Z0-9_]*$/.test(param.name);
            const camelCaseName = (0, lodash_1.camelCase)(param.name);
            const name = isPureSnakeCase && !allNames.includes(camelCaseName) ? camelCaseName : param.name;
            queryArg[name] = {
                origin: 'param',
                name,
                originalName: param.name,
                type: apiGen.getTypeFromSchema((0, generate_1.isReference)(param) ? param : param.schema),
                required: param.required,
                param,
            };
        }
        if (requestBody) {
            const body = apiGen.resolve(requestBody);
            const schema = apiGen.getSchemaFromContent(body.content);
            const type = apiGen.getTypeFromSchema(schema);
            const schemaName = (0, lodash_1.camelCase)(type.name || (0, generate_1.getReferenceName)(schema) || 'body');
            let name = schemaName in queryArg ? 'body' : schemaName;
            while (name in queryArg) {
                name = '_' + name;
            }
            queryArg[name] = {
                origin: 'body',
                name,
                originalName: schemaName,
                type: apiGen.getTypeFromSchema(schema),
                required: true,
                body,
            };
        }
        const propertyName = (name) => {
            if (typeof name === 'string') {
                return (0, tscodegen_1.isValidIdentifier)(name) ? factory_1.factory.createIdentifier(name) : factory_1.factory.createStringLiteral(name);
            }
            return name;
        };
        const queryArgValues = Object.values(queryArg);
        const QueryArg = factory_1.factory.createTypeReferenceNode(registerInterface(factory_1.factory.createTypeAliasDeclaration(undefined, [factory_1.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)], (0, utils_1.capitalize)(operationName + argSuffix), undefined, queryArgValues.length > 0
            ? factory_1.factory.createTypeLiteralNode(queryArgValues.map((def) => {
                const comment = def.origin === 'param' ? def.param.description : def.body.description;
                const node = factory_1.factory.createPropertySignature(undefined, propertyName(def.name), (0, tscodegen_1.createQuestionToken)(!def.required), def.type);
                if (comment) {
                    return typescript_1.default.addSyntheticLeadingComment(node, typescript_1.default.SyntaxKind.MultiLineCommentTrivia, `* ${comment} `, true);
                }
                return node;
            }))
            : factory_1.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.VoidKeyword))).name);
        return (0, codegen_1.generateEndpointDefinition)({
            operationName,
            type: isQuery ? 'query' : 'mutation',
            Response: ResponseTypeName,
            QueryArg,
            queryFn: generateQueryFn({ operationDefinition, queryArg, isQuery }),
            extraEndpointsProps: isQuery
                ? generateQueryEndpointProps({ operationDefinition })
                : generateMutationEndpointProps({ operationDefinition }),
        });
    }
    function generateQueryFn({ operationDefinition, queryArg, isQuery, }) {
        const { path, verb } = operationDefinition;
        const pathParameters = Object.values(queryArg).filter((def) => def.origin === 'param' && def.param.in === 'path');
        const queryParameters = Object.values(queryArg).filter((def) => def.origin === 'param' && def.param.in === 'query');
        const headerParameters = Object.values(queryArg).filter((def) => def.origin === 'param' && def.param.in === 'header');
        const cookieParameters = Object.values(queryArg).filter((def) => def.origin === 'param' && def.param.in === 'cookie');
        const bodyParameter = Object.values(queryArg).find((def) => def.origin === 'body');
        const rootObject = factory_1.factory.createIdentifier('queryArg');
        return factory_1.factory.createArrowFunction(undefined, undefined, Object.keys(queryArg).length
            ? [
                factory_1.factory.createParameterDeclaration(undefined, undefined, undefined, rootObject, undefined, undefined, undefined),
            ]
            : [], undefined, factory_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), factory_1.factory.createParenthesizedExpression(factory_1.factory.createObjectLiteralExpression([
            factory_1.factory.createPropertyAssignment(factory_1.factory.createIdentifier('url'), generatePathExpression(path, pathParameters, rootObject)),
            isQuery && verb.toUpperCase() === 'GET'
                ? undefined
                : factory_1.factory.createPropertyAssignment(factory_1.factory.createIdentifier('method'), factory_1.factory.createStringLiteral(verb.toUpperCase())),
            bodyParameter === undefined
                ? undefined
                : factory_1.factory.createPropertyAssignment(factory_1.factory.createIdentifier('body'), factory_1.factory.createPropertyAccessExpression(rootObject, factory_1.factory.createIdentifier(bodyParameter.name))),
            cookieParameters.length === 0
                ? undefined
                : factory_1.factory.createPropertyAssignment(factory_1.factory.createIdentifier('cookies'), generateQuerArgObjectLiteralExpression(cookieParameters, rootObject)),
            headerParameters.length === 0
                ? undefined
                : factory_1.factory.createPropertyAssignment(factory_1.factory.createIdentifier('headers'), generateQuerArgObjectLiteralExpression(headerParameters, rootObject)),
            queryParameters.length === 0
                ? undefined
                : factory_1.factory.createPropertyAssignment(factory_1.factory.createIdentifier('params'), generateQuerArgObjectLiteralExpression(queryParameters, rootObject)),
        ].filter(utils_1.removeUndefined), false)));
    }
    // eslint-disable-next-line no-empty-pattern
    function generateQueryEndpointProps({}) {
        return {}; /* TODO needs implementation - skip for now */
    }
    // eslint-disable-next-line no-empty-pattern
    function generateMutationEndpointProps({}) {
        return {}; /* TODO needs implementation - skip for now */
    }
}
exports.generateApi = generateApi;
function accessProperty(rootObject, propertyName) {
    return (0, tscodegen_1.isValidIdentifier)(propertyName)
        ? factory_1.factory.createPropertyAccessExpression(rootObject, factory_1.factory.createIdentifier(propertyName))
        : factory_1.factory.createElementAccessExpression(rootObject, factory_1.factory.createStringLiteral(propertyName));
}
function generatePathExpression(path, pathParameters, rootObject) {
    const expressions = [];
    const head = path.replace(/\{(.*?)\}(.*?)(?=\{|$)/g, (_, expression, literal) => {
        const param = pathParameters.find((p) => p.originalName === expression);
        if (!param) {
            throw new Error(`path parameter ${expression} does not seem to be defined?`);
        }
        expressions.push([param.name, literal]);
        return '';
    });
    return expressions.length
        ? factory_1.factory.createTemplateExpression(factory_1.factory.createTemplateHead(head), expressions.map(([prop, literal], index) => factory_1.factory.createTemplateSpan(accessProperty(rootObject, prop), index === expressions.length - 1
            ? factory_1.factory.createTemplateTail(literal)
            : factory_1.factory.createTemplateMiddle(literal))))
        : factory_1.factory.createNoSubstitutionTemplateLiteral(head);
}
function generateQuerArgObjectLiteralExpression(queryArgs, rootObject) {
    return factory_1.factory.createObjectLiteralExpression(queryArgs.map((param) => (0, tscodegen_1.createPropertyAssignment)(param.originalName, accessProperty(rootObject, param.name)), true));
}
//# sourceMappingURL=generate.js.map